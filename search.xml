<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>21. 合并两个有序链表</title>
    <url>/2021/06/06/LeetCode_20210606/</url>
    <content><![CDATA[<p>这是废话这是废话这是废话这是废话这是废话这<br>是废话这是废话这是废话这是废话<br>这是废话这是废话这是废话这是废话这是废话这是废话这是废话</p>
<span id="more"></span>                # 在需要截断的地方加入

<p>这是废话这是废<br>话这是废话这是废话这是<br>废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废<br>话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode *head=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode *cursor=head;</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">while</span>(l1&amp;&amp;l2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val&lt;=l2-&gt;val)&#123;</span><br><span class="line">                cursor-&gt;next=l1;</span><br><span class="line">                l1=l1-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cursor-&gt;next=l2;</span><br><span class="line">                l2=l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cursor=cursor-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!l1) cursor-&gt;next=l2;</span><br><span class="line">        <span class="keyword">if</span>(!l2) cursor-&gt;next=l1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        ListNode *root=new ListNode(0);</span></span><br><span class="line"><span class="comment">        ListNode *cursor=root;</span></span><br><span class="line"><span class="comment">        ListNode *first=l1,*second=l2;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        while(first&amp;&amp;second)&#123;</span></span><br><span class="line"><span class="comment">            if(first-&gt;val &lt;= second-&gt;val)&#123;</span></span><br><span class="line"><span class="comment">                cursor-&gt;next=first;</span></span><br><span class="line"><span class="comment">                first=first-&gt;next;</span></span><br><span class="line"><span class="comment">            &#125;else&#123;</span></span><br><span class="line"><span class="comment">                cursor-&gt;next=second;</span></span><br><span class="line"><span class="comment">                second=second-&gt;next;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            cursor=cursor-&gt;next;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        if(first) cursor-&gt;next=first;</span></span><br><span class="line"><span class="comment">        if(second) cursor-&gt;next=second;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        return root-&gt;next;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>83. 删除排序链表中的重复元素</title>
    <url>/2021/06/07/LeetCode_20210607/</url>
    <content><![CDATA[<p><img src="/images/LeetCode_83.png"><br><img src="/images/LeetCode_83.png"></p>
<h1 id="在需要截断的地方加入"><a href="#在需要截断的地方加入" class="headerlink" title="在需要截断的地方加入"></a>在需要截断的地方加入</h1><p>这是废话这是废<br>话这是废话这是废话这是<br>废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废</p>
<span id="more"></span>                

<p>这是废话这是废<br>话这是废话这是废话这是<br>废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废<br>话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//总结：</span></span><br><span class="line">        <span class="comment">//1.删除结点的变形，只不过需要对删除的结点进行判断</span></span><br><span class="line">        <span class="comment">//2.注意如果使用到cursor-&gt;next-&gt;next是需要对cursor-&gt;next判断是否为空的，其他题也注意一下</span></span><br><span class="line">        <span class="comment">//3.第一直觉是使用两个辅助结点进行删除结点，但其实一个辅助节点也可以，至于错解怎么写对，看这个链接</span></span><br><span class="line">		<span class="comment">//https://blog.csdn.net/Tanyongyin/article/details/113035677</span></span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        ListNode *cursor=head;</span><br><span class="line">        <span class="keyword">while</span>(cursor-&gt;next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cursor-&gt;val==cursor-&gt;next-&gt;val)&#123;</span><br><span class="line">                cursor-&gt;next=cursor-&gt;next-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cursor=cursor-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*错解</span></span><br><span class="line"><span class="comment">        if(head==nullptr) return head;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        ListNode *first=head;</span></span><br><span class="line"><span class="comment">        ListNode *second=head;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        while(first!=nullptr)&#123;</span></span><br><span class="line"><span class="comment">            second=first-&gt;next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            while(second-&gt;val==first-&gt;val &amp;&amp; second!=nullptr)&#123;</span></span><br><span class="line"><span class="comment">                cout&lt;&lt;first-&gt;val&lt;&lt;&quot;     &quot;&lt;&lt;second-&gt;next&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">                second=second-&gt;next;</span></span><br><span class="line"><span class="comment">                </span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            first-&gt;next=second;</span></span><br><span class="line"><span class="comment">            first=second;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        return head;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>61. 旋转链表</title>
    <url>/2021/06/09/LeetCode_20210609/</url>
    <content><![CDATA[<blockquote>
<p>参考链接：</p>
<ol>
<li><a href="https://leetcode-cn.com/problems/rotate-list/submissions/">https://leetcode-cn.com/problems/rotate-list/submissions/</a></li>
<li><a href="https://www.cnblogs.com/grandyang/p/4355505.html">https://www.cnblogs.com/grandyang/p/4355505.html</a></li>
</ol>
</blockquote>
<h5 id="给你一个链表的头节点-head-，旋转链表，将链表每个节点向右移动-k-个位置。"><a href="#给你一个链表的头节点-head-，旋转链表，将链表每个节点向右移动-k-个位置。" class="headerlink" title="给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。"></a>给你一个链表的头节点 <code>head</code> ，旋转链表，将链表每个节点向右移动 k 个位置。</h5><p><img src="https://img-blog.csdnimg.cn/img_convert/192699c8d11d5f13a4f06fdf4823fd2e.png#pic_center" alt="在这里插入图片描述"></p>
<blockquote>
<p>输入：head = [1,2,3,4,5], k = 2<br>输出：[4,5,1,2,3]</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/img_convert/98af10b6c9f0f827ddb34c07b83e40c6.png#pic_center" alt="在这里插入图片描述"></p>
<blockquote>
<p>输入：head = [0,1,2], k = 4<br>输出：[2,0,1]</p>
</blockquote>
<span id="more"></span>

<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<p>一般第一想法就是使用快慢指针，通过将链表分成两部分，再重新连接链表达到旋转的效果，使用快慢指针时注意有些坑：<br>&emsp; （1）这题旋转的位置可能会大于链表长度，所以通过测出链表长度，再取余得到具体旋转位置；<br>&emsp; （2）将两段链表连接时，快慢指针分别应处于什么位置，这是需要自己在草稿纸上模拟下，确定连接时的操作。</p>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<blockquote>
<p>方法1：快慢指针</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>||head-&gt;next==<span class="literal">nullptr</span>||k==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        ListNode *root=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        root-&gt;next=head;</span><br><span class="line"></span><br><span class="line">        ListNode *cursor=head;</span><br><span class="line">        <span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cursor!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            n++;</span><br><span class="line">            cursor=cursor-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;n&lt;&lt;endl;		//测试链表的长度是否正确，第一次自己写的时候就出错了</span></span><br><span class="line">        n=k%n;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;n&lt;&lt;endl;</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//下面这个就保证了旋转的位置一定是在链表中的某个结合处，排除了旋转踏步（虽然k&gt;0，但仍不旋转）的情况</span></span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        ListNode *slow=head,*fast=head;</span><br><span class="line">        <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">            fast=fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">            fast=fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        root-&gt;next=slow-&gt;next;</span><br><span class="line">        fast-&gt;next=head;</span><br><span class="line">        slow-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*或者可以这样写，可以减少root结点的定义</span></span><br><span class="line"><span class="comment">        fast-&gt;next = head;</span></span><br><span class="line"><span class="comment">        fast = slow-&gt;next;</span></span><br><span class="line"><span class="comment">        slow-&gt;next = NULL;</span></span><br><span class="line"><span class="comment">        return fast;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*被各种特殊情况打败 或 超出时间限制*/</span></span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>||head-&gt;next==<span class="literal">nullptr</span>||k==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        ListNode *root=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        root-&gt;next=head;</span><br><span class="line">        ListNode *slow=head,*fast=head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(k--)&#123;         <span class="comment">//为了让快指针走到正确的位置不如直接测长度，然后再具体定位</span></span><br><span class="line">            fast=fast-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                fast=head;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fast==slow)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">            fast=fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        root-&gt;next=slow-&gt;next;</span><br><span class="line">        fast-&gt;next=head;</span><br><span class="line">        slow-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root-&gt;next;</span><br><span class="line">*/</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<blockquote>
<p>方法2：使链表变成循环链表，然后在具体的旋转位置处断开。喵啊~（见第二个参考链接的方法二）</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">rotateRight</span><span class="params">(ListNode *head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">        ListNode *cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next) &#123;</span><br><span class="line">            ++n;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = head;</span><br><span class="line">        <span class="keyword">int</span> m = n - k % n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *newhead = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> newhead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>24. 两两交换链表中的节点</title>
    <url>/2021/06/08/LeetCode_20210608/</url>
    <content><![CDATA[<h1 id="在需要截断的地方加入"><a href="#在需要截断的地方加入" class="headerlink" title="在需要截断的地方加入"></a>在需要截断的地方加入</h1><p>这是废话这是废<br>话这是废话这是废话这是<br>废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废</p>
<span id="more"></span>                

<p>这是废话这是废<br>话这是废话这是废话这是<br>废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废<br>话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> //递归</span></span><br><span class="line"><span class="comment">class Solution &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    ListNode* swapPairs(ListNode* head) &#123;</span></span><br><span class="line"><span class="comment">        if(head==nullptr||head-&gt;next==nullptr)</span></span><br><span class="line"><span class="comment">            return head;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        ListNode *temp=head-&gt;next;</span></span><br><span class="line"><span class="comment">        head-&gt;next=swapPairs(head-&gt;next-&gt;next);</span></span><br><span class="line"><span class="comment">        temp-&gt;next=head;</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        return temp;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ListNode *root=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        root-&gt;next=head;</span><br><span class="line"></span><br><span class="line">        ListNode *tmp=root;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(tmp-&gt;next!=<span class="literal">nullptr</span>)&#123;              <span class="comment">//如果是偶数个结点直接跳出循环</span></span><br><span class="line">            ListNode *left=tmp-&gt;next;</span><br><span class="line">            ListNode *right=left-&gt;next;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(left-&gt;next!=<span class="literal">nullptr</span>)&#123;            </span><br><span class="line">                tmp-&gt;next=right;</span><br><span class="line">                left-&gt;next=right-&gt;next;</span><br><span class="line">                right-&gt;next=left;       <span class="comment">//这里的left和right不要写反了</span></span><br><span class="line"></span><br><span class="line">                cout&lt;&lt;left-&gt;val&lt;&lt;<span class="string">&quot;       &quot;</span>&lt;&lt;right-&gt;val&lt;&lt;endl;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;                      <span class="comment">//这里是判断最后剩一个结点的情况，也就是奇数个节点的情况</span></span><br><span class="line">                <span class="keyword">return</span> root-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            tmp=left;       <span class="comment">//注意这里不要写成tmp=right,因为left和right的位置调换了</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root-&gt;next;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        ListNode *root=new ListNode(0);</span></span><br><span class="line"><span class="comment">        root-&gt;next=head;</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        ListNode *cursor=root;</span></span><br><span class="line"><span class="comment">        while(cursor-&gt;next!=nullptr&amp;&amp;cursor-&gt;next-&gt;next!=nullptr)&#123;//注意条件是“&amp;&amp;”，不是“||”</span></span><br><span class="line"><span class="comment">            ListNode *p=cursor-&gt;next;</span></span><br><span class="line"><span class="comment">            ListNode *q=p-&gt;next;</span></span><br><span class="line"><span class="comment">            </span></span><br><span class="line"><span class="comment">            cursor-&gt;next=q;</span></span><br><span class="line"><span class="comment">            p-&gt;next=q-&gt;next;</span></span><br><span class="line"><span class="comment">            q-&gt;next=p;</span></span><br><span class="line"><span class="comment">            cursor=cursor-&gt;next-&gt;next;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        return root-&gt;next;*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>86. 分隔链表</title>
    <url>/2021/06/10/LeetCode_20210610/</url>
    <content><![CDATA[<blockquote>
<p>参考链接：</p>
<ol>
<li><a href="https://leetcode-cn.com/problems/rotate-list/submissions/">https://leetcode-cn.com/problems/rotate-list/submissions/</a></li>
<li><a href="https://www.cnblogs.com/grandyang/p/4355505.html">https://www.cnblogs.com/grandyang/p/4355505.html</a></li>
</ol>
</blockquote>
<p><strong>给你一个链表的头节点 <code>head</code> 和一个特定值 <code>x</code> ，请你对链表进行分隔，使得所有 小于<code>x</code> 的节点都出现在 大于或等于 <code>x</code> 的节点之前。你应当 保留 两个分区中每个节点的初始相对位置。</strong></p>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<p>示例1：<br><img src="https://assets.leetcode.com/uploads/2021/01/04/partition.jpg" alt="在这里插入图片描述"></p>
<blockquote>
<p>输入：head = [1,4,3,2,5,2], x = 3<br>输出：[1,2,2,4,3,5]</p>
</blockquote>
<p>示例2：</p>
<blockquote>
<p>输入：head = [2,1], x = 2<br>输出：[1,2]</p>
</blockquote>
<span id="more"></span>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<h3 id="方法一：分成两个链表"><a href="#方法一：分成两个链表" class="headerlink" title="方法一：分成两个链表"></a>方法一：分成两个链表</h3><p>自己的第一想法是将初始的链表分成两个满足题目条件的链表，然后再根据题目条件将这两个链表进行连接即可.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">partition</span><span class="params">(ListNode* head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        ListNode *l1=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode *l2=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        ListNode *cur1=l1;</span><br><span class="line">        ListNode *cur2=l2;</span><br><span class="line"></span><br><span class="line">        ListNode *cursor=head;</span><br><span class="line">        <span class="keyword">while</span>(cursor!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cursor-&gt;val &lt; x)&#123;</span><br><span class="line">                cur1-&gt;next=cursor;</span><br><span class="line">                cur1=cur1-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur2-&gt;next=cursor;</span><br><span class="line">                cur2=cur2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cursor=cursor-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur1-&gt;next=l2-&gt;next;</span><br><span class="line">        cur2-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> l1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<h3 id="方法二：自己再定义一个链表"><a href="#方法二：自己再定义一个链表" class="headerlink" title="方法二：自己再定义一个链表"></a>方法二：自己再定义一个链表</h3><p>将所有小于给定值的节点取出组成一个新的链表，此时原链表中剩余的节点的值都大于或等于给定值，只要将原链表直接接在新链表后即可<br>其实再想一下这道题的这个想法，也就是删除节点，只是被删除的结点需要放到另一个新的链表中，所以和之前做的<code>83. 删除排序链表中的重复元素</code>有一些类似之处，只是删除的结点操作不同而已<br>此种解法链表变化顺序为：</p>
<p>Original: 1 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 2 </p>
<p>New:</p>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>
 
<p>Original: 4 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 2 </p>
<p>New:　  1</p>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>
 
<p>Original: 4 -&gt; 3 -&gt; 5 -&gt; 2 </p>
<p>New:　  1 -&gt; 2</p>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<p>Original: 4 -&gt; 3 -&gt; 5 </p>
<p>New:　  1 -&gt; 2 -&gt; 2</p>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>
 
<p>Original: </p>
<p>New:　  1 -&gt; 2 -&gt; 2 -&gt; 4 -&gt; 3 -&gt; 5 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">partition</span><span class="params">(ListNode *head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        ListNode *newDummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line"></span><br><span class="line">        ListNode *cur = dummy, *p = newDummy;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;next-&gt;val &lt; x) &#123;</span><br><span class="line">			<span class="comment">//除了删除结点的那步，其余的三步骤都是对被删除结点的特殊操作</span></span><br><span class="line">                p-&gt;next = cur-&gt;next;				</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next;		<span class="comment">//这是相当于删除结点的关键步骤</span></span><br><span class="line">                p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;next = dummy-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> newDummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<h3 id="方法三：移动结点"><a href="#方法三：移动结点" class="headerlink" title="方法三：移动结点"></a>方法三：移动结点</h3><p>这道题要求我们划分链表，把所有小于给定值的节点都移到前面，大于该值的节点顺序不变，相当于一个局部排序的问题。那么可以想到的一种解法是首先找到第一个大于或等于给定值的节点，用题目中给的例子来说就是先找到4，然后再找小于3的值，每找到一个就将其取出置于4之前即可</p>
<pre><code>dummy 
  *    -    1    |-    4    -    3    -    2    -    5    -    nullptr
            pre                 cur        tmp                            
(pre-&gt;next-&gt;val &gt; x                cur-&gt;next-&gt;val &lt; x)

变成

dummy 
  *    -    1    -    2    |-    4    -    3    -    5    -    nullptr
                    pre/tmp               cur                
</code></pre>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">partition</span><span class="params">(ListNode *head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        ListNode *pre = dummy, *cur = head;;</span><br><span class="line">        <span class="keyword">while</span> (pre-&gt;next &amp;&amp; pre-&gt;next-&gt;val &lt; x) pre = pre-&gt;next;</span><br><span class="line">        cur = pre;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;next-&gt;val &lt; x) &#123;</span><br><span class="line">                ListNode *tmp = cur-&gt;next;</span><br><span class="line">                cur-&gt;next = tmp-&gt;next;</span><br><span class="line">                tmp-&gt;next = pre-&gt;next;</span><br><span class="line">                pre-&gt;next = tmp;</span><br><span class="line">                pre = pre-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>2. 两数相加</title>
    <url>/2021/06/18/LeetCode_20210618/</url>
    <content><![CDATA[<blockquote>
<p>参考链接：</p>
<ol>
<li><a href="https://leetcode-cn.com/problems/add-two-numbers/">https://leetcode-cn.com/problems/add-two-numbers/</a></li>
<li><a href="https://grandyang.com/leetcode/2/">https://grandyang.com/leetcode/2/</a></li>
</ol>
</blockquote>
<p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<p>示例1：<br><img src="/images/LeetCode_2.jpg"></p>
<blockquote>
<p>输入：l1 = [2,4,3], l2 = [5,6,4]<br>输出：[7,0,8]<br>解释：342 + 465 = 807</p>
</blockquote>
<p>示例2：</p>
<blockquote>
<p>输入：l1 = [0], l2 = [0]<br>输出：[0]</p>
</blockquote>
<p>示例3：</p>
<blockquote>
<p>输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]<br>输出：[8,9,9,9,0,0,0,1]</p>
</blockquote>
<span id="more"></span>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>


<h3 id="方法一：while循环条件为：l1-l2"><a href="#方法一：while循环条件为：l1-l2" class="headerlink" title="方法一：while循环条件为：l1||l2"></a>方法一：while循环条件为：l1||l2</h3><p>需要在循环之后对进位carry进行判断</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode *head=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode *cursor=head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> carry=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1||l2)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum=(l1?l1-&gt;val:<span class="number">0</span>)+(l2?l2-&gt;val:<span class="number">0</span>)+carry;</span><br><span class="line">            carry=sum/<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">            cursor-&gt;next=<span class="keyword">new</span> <span class="built_in">ListNode</span>(sum%<span class="number">10</span>);</span><br><span class="line">            cursor=cursor-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(l1) l1=l1-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(l2) l2=l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry&gt;<span class="number">0</span>) </span><br><span class="line">            cursor-&gt;next=<span class="keyword">new</span> <span class="built_in">ListNode</span>(carry);	<span class="comment">//也可以写成cursor-&gt;next=new ListNode(1);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">        ListNode *head=nullptr;</span></span><br><span class="line"><span class="comment">	ListNode *cursor=head;</span></span><br><span class="line"><span class="comment">        int carry=0;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        while(l1||l2)&#123;</span></span><br><span class="line"><span class="comment">            int n1=l1?l1-&gt;val:0;</span></span><br><span class="line"><span class="comment">            int n2=l2?l2-&gt;val:0;</span></span><br><span class="line"><span class="comment">            int sum=n1+n2+carry;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            if(!head)&#123;</span></span><br><span class="line"><span class="comment">                //因为是第一个节点，所以head和tail的操作相同</span></span><br><span class="line"><span class="comment">                //当然可以在结果返回head-&gt;next，直接不用这个分支</span></span><br><span class="line"><span class="comment">                head=cursor=new ListNode(sum%10);</span></span><br><span class="line"><span class="comment">            &#125;else&#123;</span></span><br><span class="line"><span class="comment">                cursor-&gt;next=new ListNode(sum%10);</span></span><br><span class="line"><span class="comment">                cursor=cursor-&gt;next;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            carry=sum/10;</span></span><br><span class="line"><span class="comment">            if(l1) l1=l1-&gt;next;</span></span><br><span class="line"><span class="comment">            if(l2) l2=l2-&gt;next;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        if(carry&gt;0)&#123;</span></span><br><span class="line"><span class="comment">            cursor-&gt;next=new ListNode(carry);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        return head;	//注意这里返回的节点不同，所以在创建第一个节点也和第一种写法不同</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">		</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<h3 id="方法二：while循环条件为：l1-l2-carry-0"><a href="#方法二：while循环条件为：l1-l2-carry-0" class="headerlink" title="方法二：while循环条件为：l1||l2||carry!=0"></a>方法二：while循环条件为：l1||l2||carry!=0</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ListNode *head=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode *cursor=head;</span><br><span class="line">        <span class="keyword">int</span> carry=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="literal">nullptr</span> || l2!=<span class="literal">nullptr</span> ||carry!=<span class="number">0</span>)&#123;       <span class="comment">//注意跳出循环条件</span></span><br><span class="line">            <span class="keyword">int</span> sum = (l1?l1-&gt;val:<span class="number">0</span>)+(l2?l2-&gt;val:<span class="number">0</span>)+carry;</span><br><span class="line"></span><br><span class="line">            cursor-&gt;next=<span class="keyword">new</span> <span class="built_in">ListNode</span>(sum%<span class="number">10</span>);      <span class="comment">//注意如何伸展出新的链表部分</span></span><br><span class="line">            cursor=cursor-&gt;next;</span><br><span class="line"></span><br><span class="line">            carry=sum/<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(l1!=<span class="literal">nullptr</span>) l1=l1-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(l2!=<span class="literal">nullptr</span>) l2=l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>237. 删除链表中的节点</title>
    <url>/2021/06/20/LeetCode_20210620/</url>
    <content><![CDATA[<blockquote>
<p>参考链接：</p>
<ol>
<li><a href="https://leetcode-cn.com/problems/rotate-list/submissions/">https://leetcode-cn.com/problems/rotate-list/submissions/</a></li>
<li><a href="https://www.cnblogs.com/grandyang/p/4355505.html">https://www.cnblogs.com/grandyang/p/4355505.html</a></li>
</ol>
</blockquote>
<p><strong>请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点。传入函数的唯一参数为 <code>要被删除的节点</code> 。</strong></p>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<p>现有一个链表 – head = [4,5,1,9]，它可以表示为:</p>
<img src="/images/LeetCode_237.png">

<p>示例1：</p>
<blockquote>
<p>输入：head = [4,5,1,9], node = 5<br>输出：[4,1,9]<br>解释：给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</p>
</blockquote>
<p>示例2：</p>
<blockquote>
<p>输入：head = [4,5,1,9], node = 1<br>输出：[4,5,9]<br>解释：给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</p>
</blockquote>
<span id="more"></span>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<h3 id="方法：删除链表的节点（通过赋值下一节点的值来进行删除）"><a href="#方法：删除链表的节点（通过赋值下一节点的值来进行删除）" class="headerlink" title="方法：删除链表的节点（通过赋值下一节点的值来进行删除）"></a>方法：删除链表的节点（通过赋值下一节点的值来进行删除）</h3><p>自己的第一想法是将初始的链表分成两个满足题目条件的链表，然后再根据题目条件将这两个链表进行连接即可.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//在只给定被删除节点的情况下，删除该节点，并没有给出head结点</span></span><br><span class="line"></span><br><span class="line">        node-&gt;val=node-&gt;next-&gt;val;</span><br><span class="line">        node-&gt;next=node-&gt;next-&gt;next;</span><br><span class="line">		</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	注意另一种删除节点的方法是通过删除节点的前一节点辅助，使用了一个cursor-&gt;next</span></span><br><span class="line"><span class="comment">	而且注意while循环的判断条件，这在其他题目中也会遇到</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	ListNode *root=new ListNode(0);</span></span><br><span class="line"><span class="comment">        root-&gt;next=head;</span></span><br><span class="line"><span class="comment">        ListNode *cursor=root;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        while(cursor-&gt;next!=nullptr)&#123;</span></span><br><span class="line"><span class="comment">            if(cursor-&gt;next-&gt;val==node-&gt;val)&#123;</span></span><br><span class="line"><span class="comment">                cursor-&gt;next=cursor-&gt;next-&gt;next;</span></span><br><span class="line"><span class="comment">                return ;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            else</span></span><br><span class="line"><span class="comment">                cursor=cursor-&gt;next;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return ;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>234. 回文链表</title>
    <url>/2021/06/21/LeetCode_20210621/</url>
    <content><![CDATA[<blockquote>
<p>参考链接：</p>
<ol>
<li><a href="https://leetcode-cn.com/problems/rotate-list/submissions/">https://leetcode-cn.com/problems/rotate-list/submissions/</a></li>
<li><a href="https://www.cnblogs.com/grandyang/p/4355505.html">https://www.cnblogs.com/grandyang/p/4355505.html</a></li>
</ol>
</blockquote>
<p><strong>请判断一个链表是否为回文链表。</strong></p>
<p>示例1：</p>
<blockquote>
<p>输入: 1-&gt;2<br>输出: false</p>
</blockquote>
<p>示例2：</p>
<blockquote>
<p>输入: 1-&gt;2-&gt;2-&gt;1<br>输出: true</p>
</blockquote>
<p>进阶：<br>你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p>
<span id="more"></span>
<p>这道题让我们判断一个链表是否为回文链表，LeetCode 中关于回文串的题共有六道，除了这道，其他的五道为<br><a href="https://leetcode-cn.com/problems/palindrome-number/">9. 回文数</a>，<br><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">5. 最长回文子串</a>，<br><a href="https://leetcode-cn.com/problems/palindrome-partitioning">131. 分割回文串</a>，<br><a href="https://leetcode-cn.com/problems/palindrome-partitioning-ii">132. 分割回文串 II</a>，<br><a href="https://leetcode-cn.com/problems/valid-palindrome">125. 验证回文串</a>.</p>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<h3 id="方法一：分成两个链表，第二个链表再反转，对两个链表中的数据一一对比"><a href="#方法一：分成两个链表，第二个链表再反转，对两个链表中的数据一一对比" class="headerlink" title="方法一：分成两个链表，第二个链表再反转，对两个链表中的数据一一对比"></a>方法一：分成两个链表，第二个链表再反转，对两个链表中的数据一一对比</h3><p>自己的第一想法是将初始的链表分成两个链表，因为是回文链表，所以需要对第二个链表进行反转，然后再对两个链表的对应数据进行对比，得出结论<br>（至于如何对第二个链表进行反转，可以参考<code>206.反转链表</code>）.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>||head-&gt;next==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        ListNode* pre  = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        pre-&gt;next=head;</span><br><span class="line"></span><br><span class="line">        ListNode *slow=pre,*fast=pre;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="literal">nullptr</span> &amp;&amp; fast-&gt;next!=<span class="literal">nullptr</span>) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fast != <span class="literal">nullptr</span>) &#123;     <span class="comment">//偶数个</span></span><br><span class="line">            fast = slow-&gt;next;</span><br><span class="line">            slow-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">            fast=<span class="built_in">ReverseList</span>(fast);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(fast==<span class="literal">nullptr</span>) &#123;        <span class="comment">//奇数个</span></span><br><span class="line">            fast=slow-&gt;next;</span><br><span class="line">            slow=<span class="literal">nullptr</span>;</span><br><span class="line">            fast=<span class="built_in">ReverseList</span>(fast);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">nullptr</span>&amp;&amp;fast!=<span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(head-&gt;val!=fast-&gt;val) &#123;</span><br><span class="line">                <span class="comment">//cout&lt;&lt;head-&gt;val&lt;&lt;&quot;  &quot;&lt;&lt;fast-&gt;val&lt;&lt;endl;</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">            fast=fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">ReverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* cursor=head;</span><br><span class="line">        ListNode* pre=<span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cursor) &#123;</span><br><span class="line">            ListNode* NextNode=cursor-&gt;next;</span><br><span class="line">            cursor-&gt;next=pre;</span><br><span class="line">            pre=cursor;</span><br><span class="line">            cursor=NextNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<h3 id="方法二：使用栈的先进后出特性，进一半，验证另一半"><a href="#方法二：使用栈的先进后出特性，进一半，验证另一半" class="headerlink" title="方法二：使用栈的先进后出特性，进一半，验证另一半"></a>方法二：使用栈的先进后出特性，进一半，验证另一半</h3><p>（注意使用了栈，这时的空间复杂度不为o(1)）<br>链表比字符串难的地方就在于不能通过坐标来直接访问，而只能从头开始遍历到某个位置。那么根据回文串的特点，我们需要比较对应位置的值是否相等，一个非常直接的思路就是先按顺序把所有的结点值都存入到一个栈 stack 里，然后利用栈的后入先出的特性，就可以按顺序从末尾取出结点值了，此时再从头遍历一遍链表，就可以比较回文的对应位置了，若不同直接返回 false 即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *cur = head;</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(cur-&gt;val);</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = st.<span class="built_in">top</span>(); st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (head-&gt;val != t) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		//也可使用数组</span></span><br><span class="line"><span class="comment">        vector&lt;int&gt; v;</span></span><br><span class="line"><span class="comment">        while(head)&#123;</span></span><br><span class="line"><span class="comment">            v.push_back(head-&gt;val);</span></span><br><span class="line"><span class="comment">            head = head-&gt;next;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        // 判断是否回文</span></span><br><span class="line"><span class="comment">        for(int i=0; i&lt;v.size()/2; ++i)&#123;</span></span><br><span class="line"><span class="comment">            if(v[i] != v[v.size()-1-i])&#123;</span></span><br><span class="line"><span class="comment">                return false;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return true;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<h3 id="方法三："><a href="#方法三：" class="headerlink" title="方法三："></a>方法三：</h3><p>我们也可以用迭代的形式来实现，此时需要使用一个全局变量结点 cur，先初始化为头结点，可以有两种写法，一种写在函数外面的全局变量，或者是在递归函数的参数中加上引用，也表示使用的是全局变量。然后对头结点调用递归函数，在递归函数中，首先判空，若为空则直接返回 true，否则就对下一个结点调用递归函数，若递归函数返回 true 且同时再当前结点值跟 cur 的结点值相同的话，就表明是回文串，否则就不是，注意每次 cur 需要指向下一个结点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *cur = head;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(head, cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(ListNode* node, ListNode*&amp; cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">bool</span> res = <span class="built_in">helper</span>(node-&gt;next, cur) &amp;&amp; (cur-&gt;val == node-&gt;val);</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>


<h3 id="方法四："><a href="#方法四：" class="headerlink" title="方法四："></a>方法四：</h3><p>其实上面的两种解法重复比较一些结点，因为只要前半个链表和后半个链表对应值相等，就是一个回文链表，而并不需要再比较一遍后半个链表，所以我们可以找到链表的中点，这个可以用快慢指针来实现，使用方法可以参见之前的两篇 Convert Sorted List to Binary Search Tree 和 Reorder List，使用快慢指针找中点的原理是 fast 和 slow 两个指针，每次快指针走两步，慢指针走一步，等快指针走完时，慢指针的位置就是中点。我们还需要用栈，每次慢指针走一步，都把值存入栈中，等到达中点时，链表的前半段都存入栈中了，由于栈的后进先出的性质，就可以和后半段链表按照回文对应的顺序比较了，参见代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        ListNode *slow = head, *fast = head;</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; st&#123;&#123;head-&gt;val&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span> (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            st.<span class="built_in">push</span>(slow-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!fast-&gt;next) st.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">while</span> (slow-&gt;next) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">int</span> tmp = st.<span class="built_in">top</span>(); st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (tmp != slow-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
        <tag>回文串</tag>
      </tags>
  </entry>
  <entry>
    <title>206. 反转链表</title>
    <url>/2021/06/22/LeetCode_20210622/</url>
    <content><![CDATA[<blockquote>
<p>参考链接：</p>
<ol>
<li><a href="https://leetcode-cn.com/problems/rotate-list/submissions/">https://leetcode-cn.com/problems/rotate-list/submissions/</a></li>
<li><a href="https://www.cnblogs.com/grandyang/p/4355505.html">https://www.cnblogs.com/grandyang/p/4355505.html</a></li>
</ol>
</blockquote>
<p><strong>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</strong></p>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<p>示例1：<br><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="在这里插入图片描述"></p>
<blockquote>
<p>输入：head = [1,2,3,4,5]<br>输出：[5,4,3,2,1]</p>
</blockquote>
<p>示例2：<br><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg" alt="在这里插入图片描述"></p>
<blockquote>
<p>输入：head = [1,2]<br>输出：[2,1]</p>
</blockquote>
<p>示例3：</p>
<blockquote>
<p>输入：head = []<br>输出：[]</p>
</blockquote>
<p>进阶：链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p>
<span id="more"></span>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<h3 id="方法一：迭代"><a href="#方法一：迭代" class="headerlink" title="方法一：迭代"></a>方法一：迭代</h3><p>可以将该题转换为 两个链表，新建一个链表，然后从旧链表中依次取下头节点，然后当成新链表的头节点<br><img src="/images/LeetCode_206.jpg"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *newHead = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            ListNode *t = head-&gt;next;</span><br><span class="line">            head-&gt;next = newHead;</span><br><span class="line">            newHead = head;</span><br><span class="line">            head = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<h3 id="方法二：递归"><a href="#方法二：递归" class="headerlink" title="方法二：递归"></a>方法二：递归</h3><p>下面我们来看递归解法，代码量更少，递归解法的思路是，不断的进入递归函数，直到head指向倒数第二个节点，因为head指向空或者是最后一个结点都直接返回了，newHead则指向对head的下一个结点调用递归函数返回的头结点，此时newHead指向最后一个结点，然后head的下一个结点的next指向head本身，这个相当于把head结点移动到末尾的操作，因为是回溯的操作，所以head的下一个结点总是在上一轮被移动到末尾了，但head之后的next还没有断开，所以可以顺势将head移动到末尾，再把next断开，最后返回newHead即可，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *newHead = <span class="built_in">reverseList</span>(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>92. 反转链表 II</title>
    <url>/2021/06/23/LeetCode_20210623/</url>
    <content><![CDATA[<blockquote>
<p>参考链接： </p>
<ol>
<li><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/solution/fan-zhuan-lian-biao-ii-by-leetcode-solut-teyq/">https://leetcode-cn.com/problems/reverse-linked-list-ii/solution/fan-zhuan-lian-biao-ii-by-leetcode-solut-teyq/</a></li>
<li><a href="https://grandyang.com/leetcode/92/">https://grandyang.com/leetcode/92/</a></li>
</ol>
</blockquote>
<p>给你单链表的头指针 <code>head</code> 和两个整数 <code>left</code> 和 <code>right</code> ，其中 <code>left &lt;= right</code> 。请你反转从位置 <code>left</code> 到位置 <code>right</code> 的链表节点，返回 __反转后的链表 __ 。</p>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<p>示例1：<br><img src="https://assets.leetcode.com/uploads/2021/02/19/rev2ex2.jpg" alt="在这里插入图片描述"></p>
<blockquote>
<p>输入：head = [1,2,3,4,5], left = 2, right = 4<br>输出：[1,4,3,2,5]</p>
</blockquote>
<p>示例2：</p>
<blockquote>
<p>输入：head = [5], left = 1, right = 1<br>输出：[5]</p>
</blockquote>
<p>进阶： 你可以使用一趟扫描完成反转吗？</p>
<span id="more"></span>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<h3 id="方法一：穿针引线"><a href="#方法一：穿针引线" class="headerlink" title="方法一：穿针引线"></a>方法一：穿针引线</h3><p>使用「206. 反转链表」的解法，反转 left 到 right 部分以后，再拼接起来。我们还需要记录 left 的前一个节点，和 right 的后一个节点。链表的操作问题，一般而言面试（机试）的时候不允许我们修改节点的值，而只能修改节点的指向操作。</p>
<p>思路通常都不难，写对链表问题的技巧是：一定要先想清楚思路，并且必要的时候在草稿纸上画图，理清「穿针引线」的先后步骤，然后再编码。<br><img src="/images/LeetCode_92_1.jpg"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 因为头节点有可能发生变化，使用虚拟头节点可以避免复杂的分类讨论        </span></span><br><span class="line">        ListNode *dummy=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummy-&gt;next=head;</span><br><span class="line">        ListNode *pre=dummy;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第 1 步：从虚拟头节点走 left - 1 步，来到 left 节点的前一个节点</span></span><br><span class="line">        <span class="comment">// 建议写在 for 循环里，语义清晰</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;left;i++)&#123;</span><br><span class="line">            pre=pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第 2 步：从 pre 走到 right 节点</span></span><br><span class="line">        ListNode *l=pre-&gt;next,*r=pre-&gt;next;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;right-left;i++)&#123;</span><br><span class="line">            r=r-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第 3 步：切断出一个子链表（截取链表）</span></span><br><span class="line">        ListNode *post=r-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意：切断链接</span></span><br><span class="line">        pre-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">        r-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第 4 步：同第 206 题，反转链表的子区间</span></span><br><span class="line">        <span class="comment">//若是有返回节点的函数，应该写成r=reverseList(l);注意r在前面了</span></span><br><span class="line">        <span class="built_in">reverseList</span>(l);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第 5 步：接回到原来的链表中</span></span><br><span class="line">        <span class="comment">//***注意，反转链表后，r和l的位置调换了</span></span><br><span class="line">        pre-&gt;next=r;</span><br><span class="line">        l-&gt;next=post;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//反转链表</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *newHead = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            ListNode *t = head-&gt;next;</span><br><span class="line">            head-&gt;next = newHead;</span><br><span class="line">            newHead = head;</span><br><span class="line">            head = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<h3 id="方法二：一次遍历「穿针引线」反转链表（头插法）"><a href="#方法二：一次遍历「穿针引线」反转链表（头插法）" class="headerlink" title="方法二：一次遍历「穿针引线」反转链表（头插法）"></a>方法二：一次遍历「穿针引线」反转链表（头插法）</h3><p>对于链表的问题，根据以往的经验一般都是要建一个dummy node，连上原链表的头结点，这样的话就算头结点变动了，我们还可以通过dummy-&gt;next来获得新链表的头结点。这道题的要求是只通过一次遍历完成，就拿题目中的例子来说，变换的是2,3,4这三个点，我们需要找到第一个开始变换结点的前一个结点，只要让pre向后走m-1步即可，为啥要减1呢，因为题目中是从1开始计数的，这里只走了1步，就是结点1，用pre指向它。万一是结点1开始变换的怎么办，这就是我们为啥要用dummy结点了，pre也可以指向dummy结点。然后就要开始交换了，由于一次只能交换两个结点，所以我们按如下的交换顺序：</p>
<p>1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7-&gt; NULL</p>
<p>1 -&gt; 2 -&gt; 4 -&gt; 3 -&gt; 5 -&gt; 6 -&gt; 7-&gt; NULL</p>
<p>1 -&gt; 2 -&gt; 5 -&gt; 4 -&gt; 3 -&gt; 6 -&gt; 7-&gt; NULL</p>
<p>1 -&gt; 2 -&gt; 6 -&gt; 5 -&gt; 4 -&gt; 3 -&gt; 7-&gt; NULL</p>
<p>我们可以看出来，总共需要n-m步即可，<br>    第一步是将结点4放到结点2的后面，<br>    第二步将结点5放到结点2的后面，<br>    第二步将结点6放到结点2的后面，<br>这是很有规律的操作，那么我们就说一个就行了，比如刚开始，pre指向结点2，cur指向结点3，然后我们建立一个临时的结点tmp，指向结点4（注意我们用临时变量保存某个结点就是为了首先断开该结点和前面结点之间的联系，这可以当作一个规律记下来），然后我们断开结点3和结点4，将结点3的next连到结点5上，也就是 cur-&gt;next = tmp-&gt;next，再把结点4连到结点2的后面结点（即结点3）的前面，即 tmp-&gt;next = pre-&gt;next，最后再将原来的结点2和结点3的连接断开，将结点2连到结点4，即 pre-&gt;next = tmp。这样我们就完成了将结点4取出，加入结点2的后方。第二步也是同样的操作，这里就不多说了，请大家自己尝试下吧，参见代码如下：<br> <img src="/images/LeetCode_92_2.jpg"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">reverseBetween</span><span class="params">(ListNode *head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>), *pre = dummy;</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; ++i) pre = pre-&gt;next;</span><br><span class="line">        ListNode *cur = pre-&gt;next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &lt; n; ++i) &#123;</span><br><span class="line">            ListNode *t = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = t-&gt;next;</span><br><span class="line">            t-&gt;next = pre-&gt;next;</span><br><span class="line">            pre-&gt;next = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>203. 移除链表元素</title>
    <url>/2021/06/19/Leetcode_20210619/</url>
    <content><![CDATA[<blockquote>
<p>参考链接：</p>
<ol>
<li><a href="https://leetcode-cn.com/problems/remove-linked-list-elements/">https://leetcode-cn.com/problems/remove-linked-list-elements/</a></li>
<li><a href="https://grandyang.com/leetcode/203/">https://grandyang.com/leetcode/203/</a></li>
</ol>
</blockquote>
<p>给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。</p>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<p>示例1：<br><img src="https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg" alt="在这里插入图片描述"></p>
<blockquote>
<p>输入：head = [1,2,6,3,4,5,6], val = 6<br>输出：[1,2,3,4,5]</p>
</blockquote>
<p>示例2：</p>
<blockquote>
<p>输入：head = [], val = 1<br>输出：[]</p>
</blockquote>
<p>示例3：</p>
<blockquote>
<p>输入：head = [7,7,7,7], val = 7<br>输出：[]</p>
</blockquote>
<span id="more"></span>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<h3 id="方法一：迭代"><a href="#方法一：迭代" class="headerlink" title="方法一：迭代"></a>方法一：迭代</h3><p>使用cursor-&gt;next=cursor-&gt;next-&gt;next的方式删除节点，注意while的判断条件为cursor-&gt;next</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode *dummy=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummy-&gt;next=head;</span><br><span class="line"></span><br><span class="line">        ListNode *cursor=dummy;</span><br><span class="line">        <span class="keyword">while</span>(cursor-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cursor-&gt;next-&gt;val==val)</span><br><span class="line">                cursor-&gt;next=cursor-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cursor=cursor-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//严格写法：要对删除的节点赋空</span></span><br><span class="line">		ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line"></span><br><span class="line">		LisNode *cursor=dummy;</span><br><span class="line">        <span class="keyword">while</span> (cursor-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cursor-&gt;next-&gt;val == val) &#123;</span><br><span class="line">                ListNode *t = cursor-&gt;next;</span><br><span class="line">                cursor-&gt;next = t-&gt;next;</span><br><span class="line">                t-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">delete</span> t;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cursor = cursor-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<h3 id="方法二：递归"><a href="#方法二：递归" class="headerlink" title="方法二：递归"></a>方法二：递归</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        head-&gt;next = <span class="built_in">removeElements</span>(head-&gt;next, val);</span><br><span class="line">        <span class="keyword">return</span> head-&gt;val == val ? head-&gt;next : head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/06/04/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="��������-YWH-Hello-World"><a href="#��������-YWH-Hello-World" class="headerlink" title="�������� YWH  Hello World"></a>�������� YWH  Hello World</h2><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <tags>
        <tag>ywh</tag>
      </tags>
  </entry>
  <entry>
    <title>杨文豪的文章</title>
    <url>/2021/06/05/my-first-article/</url>
    <content><![CDATA[<p>这里是正文这里是正文这里是正文这里是正文这里是正文这里是正文这里是正文这里是正文这里是正文这里是正文这里是正文这里是正文</p>
]]></content>
      <categories>
        <category>hexo+github博客搭建</category>
        <category>yyy</category>
      </categories>
      <tags>
        <tag>ywh</tag>
        <tag>uzl</tag>
      </tags>
  </entry>
  <entry>
    <title>ywh&#39;s article</title>
    <url>/2021/06/04/ywh-s-article/</url>
    <content><![CDATA[<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><p>11111111111</p>
<hr>
<h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><p>2222222222</p>
<hr>
<p>##啪啪啪啪啪啪</p>
<p>333333333</p>
]]></content>
      <categories>
        <category>yyy</category>
      </categories>
      <tags>
        <tag>yzl</tag>
      </tags>
  </entry>
</search>
