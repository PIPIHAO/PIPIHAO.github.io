<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2021/06/04/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="��������-YWH-Hello-World"><a href="#��������-YWH-Hello-World" class="headerlink" title="�������� YWH  Hello World"></a>�������� YWH  Hello World</h2><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <tags>
        <tag>ywh</tag>
      </tags>
  </entry>
  <entry>
    <title>ywh&#39;s article</title>
    <url>/2021/06/04/ywh-s-article/</url>
    <content><![CDATA[<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><p>11111111111</p>
<hr>
<h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><p>2222222222</p>
<hr>
<p>##啪啪啪啪啪啪</p>
<p>333333333</p>
]]></content>
      <categories>
        <category>yyy</category>
      </categories>
      <tags>
        <tag>yzl</tag>
      </tags>
  </entry>
  <entry>
    <title>杨文豪的文章</title>
    <url>/2021/06/05/my-first-article/</url>
    <content><![CDATA[<p>这里是正文这里是正文这里是正文这里是正文这里是正文这里是正文这里是正文这里是正文这里是正文这里是正文这里是正文这里是正文</p>
]]></content>
      <categories>
        <category>hexo+github博客搭建</category>
        <category>yyy</category>
      </categories>
      <tags>
        <tag>ywh</tag>
        <tag>uzl</tag>
      </tags>
  </entry>
  <entry>
    <title>21. 合并两个有序链表</title>
    <url>/2021/06/06/LeetCode/LeetCode_20210606/</url>
    <content><![CDATA[<p>这是废话这是废话这是废话这是废话这是废话这<br>是废话这是废话这是废话这是废话<br>这是废话这是废话这是废话这是废话这是废话这是废话这是废话</p>
<span id="more"></span>                # 在需要截断的地方加入

<p>这是废话这是废<br>话这是废话这是废话这是<br>废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废<br>话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode *head=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode *cursor=head;</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">while</span>(l1&amp;&amp;l2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val&lt;=l2-&gt;val)&#123;</span><br><span class="line">                cursor-&gt;next=l1;</span><br><span class="line">                l1=l1-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cursor-&gt;next=l2;</span><br><span class="line">                l2=l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cursor=cursor-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!l1) cursor-&gt;next=l2;</span><br><span class="line">        <span class="keyword">if</span>(!l2) cursor-&gt;next=l1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        ListNode *root=new ListNode(0);</span></span><br><span class="line"><span class="comment">        ListNode *cursor=root;</span></span><br><span class="line"><span class="comment">        ListNode *first=l1,*second=l2;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        while(first&amp;&amp;second)&#123;</span></span><br><span class="line"><span class="comment">            if(first-&gt;val &lt;= second-&gt;val)&#123;</span></span><br><span class="line"><span class="comment">                cursor-&gt;next=first;</span></span><br><span class="line"><span class="comment">                first=first-&gt;next;</span></span><br><span class="line"><span class="comment">            &#125;else&#123;</span></span><br><span class="line"><span class="comment">                cursor-&gt;next=second;</span></span><br><span class="line"><span class="comment">                second=second-&gt;next;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            cursor=cursor-&gt;next;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        if(first) cursor-&gt;next=first;</span></span><br><span class="line"><span class="comment">        if(second) cursor-&gt;next=second;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        return root-&gt;next;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>83. 删除排序链表中的重复元素</title>
    <url>/2021/06/07/LeetCode/LeetCode_20210607/</url>
    <content><![CDATA[<p><img src="/images/LeetCode_83.png"><br><img src="/images/LeetCode_83.png"></p>
<h1 id="在需要截断的地方加入"><a href="#在需要截断的地方加入" class="headerlink" title="在需要截断的地方加入"></a>在需要截断的地方加入</h1><p>这是废话这是废<br>话这是废话这是废话这是<br>废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废</p>
<span id="more"></span>                

<p>这是废话这是废<br>话这是废话这是废话这是<br>废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废<br>话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//总结：</span></span><br><span class="line">        <span class="comment">//1.删除结点的变形，只不过需要对删除的结点进行判断</span></span><br><span class="line">        <span class="comment">//2.注意如果使用到cursor-&gt;next-&gt;next是需要对cursor-&gt;next判断是否为空的，其他题也注意一下</span></span><br><span class="line">        <span class="comment">//3.第一直觉是使用两个辅助结点进行删除结点，但其实一个辅助节点也可以，至于错解怎么写对，看这个链接</span></span><br><span class="line">		<span class="comment">//https://blog.csdn.net/Tanyongyin/article/details/113035677</span></span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        ListNode *cursor=head;</span><br><span class="line">        <span class="keyword">while</span>(cursor-&gt;next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cursor-&gt;val==cursor-&gt;next-&gt;val)&#123;</span><br><span class="line">                cursor-&gt;next=cursor-&gt;next-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cursor=cursor-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*错解</span></span><br><span class="line"><span class="comment">        if(head==nullptr) return head;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        ListNode *first=head;</span></span><br><span class="line"><span class="comment">        ListNode *second=head;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        while(first!=nullptr)&#123;</span></span><br><span class="line"><span class="comment">            second=first-&gt;next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            while(second-&gt;val==first-&gt;val &amp;&amp; second!=nullptr)&#123;</span></span><br><span class="line"><span class="comment">                cout&lt;&lt;first-&gt;val&lt;&lt;&quot;     &quot;&lt;&lt;second-&gt;next&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">                second=second-&gt;next;</span></span><br><span class="line"><span class="comment">                </span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            first-&gt;next=second;</span></span><br><span class="line"><span class="comment">            first=second;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        return head;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>24. 两两交换链表中的节点</title>
    <url>/2021/06/08/LeetCode/LeetCode_20210608/</url>
    <content><![CDATA[<h1 id="在需要截断的地方加入"><a href="#在需要截断的地方加入" class="headerlink" title="在需要截断的地方加入"></a>在需要截断的地方加入</h1><p>这是废话这是废<br>话这是废话这是废话这是<br>废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废</p>
<span id="more"></span>                

<p>这是废话这是废<br>话这是废话这是废话这是<br>废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废<br>话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话这是废话</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> //递归</span></span><br><span class="line"><span class="comment">class Solution &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    ListNode* swapPairs(ListNode* head) &#123;</span></span><br><span class="line"><span class="comment">        if(head==nullptr||head-&gt;next==nullptr)</span></span><br><span class="line"><span class="comment">            return head;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        ListNode *temp=head-&gt;next;</span></span><br><span class="line"><span class="comment">        head-&gt;next=swapPairs(head-&gt;next-&gt;next);</span></span><br><span class="line"><span class="comment">        temp-&gt;next=head;</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        return temp;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ListNode *root=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        root-&gt;next=head;</span><br><span class="line"></span><br><span class="line">        ListNode *tmp=root;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(tmp-&gt;next!=<span class="literal">nullptr</span>)&#123;              <span class="comment">//如果是偶数个结点直接跳出循环</span></span><br><span class="line">            ListNode *left=tmp-&gt;next;</span><br><span class="line">            ListNode *right=left-&gt;next;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(left-&gt;next!=<span class="literal">nullptr</span>)&#123;            </span><br><span class="line">                tmp-&gt;next=right;</span><br><span class="line">                left-&gt;next=right-&gt;next;</span><br><span class="line">                right-&gt;next=left;       <span class="comment">//这里的left和right不要写反了</span></span><br><span class="line"></span><br><span class="line">                cout&lt;&lt;left-&gt;val&lt;&lt;<span class="string">&quot;       &quot;</span>&lt;&lt;right-&gt;val&lt;&lt;endl;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;                      <span class="comment">//这里是判断最后剩一个结点的情况，也就是奇数个节点的情况</span></span><br><span class="line">                <span class="keyword">return</span> root-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            tmp=left;       <span class="comment">//注意这里不要写成tmp=right,因为left和right的位置调换了</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root-&gt;next;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        ListNode *root=new ListNode(0);</span></span><br><span class="line"><span class="comment">        root-&gt;next=head;</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        ListNode *cursor=root;</span></span><br><span class="line"><span class="comment">        while(cursor-&gt;next!=nullptr&amp;&amp;cursor-&gt;next-&gt;next!=nullptr)&#123;//注意条件是“&amp;&amp;”，不是“||”</span></span><br><span class="line"><span class="comment">            ListNode *p=cursor-&gt;next;</span></span><br><span class="line"><span class="comment">            ListNode *q=p-&gt;next;</span></span><br><span class="line"><span class="comment">            </span></span><br><span class="line"><span class="comment">            cursor-&gt;next=q;</span></span><br><span class="line"><span class="comment">            p-&gt;next=q-&gt;next;</span></span><br><span class="line"><span class="comment">            q-&gt;next=p;</span></span><br><span class="line"><span class="comment">            cursor=cursor-&gt;next-&gt;next;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        return root-&gt;next;*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>86. 分隔链表</title>
    <url>/2021/06/10/LeetCode/LeetCode_20210610/</url>
    <content><![CDATA[<blockquote>
<p>参考链接：</p>
<ol>
<li><a href="https://leetcode-cn.com/problems/rotate-list/submissions/">https://leetcode-cn.com/problems/rotate-list/submissions/</a></li>
<li><a href="https://www.cnblogs.com/grandyang/p/4355505.html">https://www.cnblogs.com/grandyang/p/4355505.html</a></li>
</ol>
</blockquote>
<p><strong>给你一个链表的头节点 <code>head</code> 和一个特定值 <code>x</code> ，请你对链表进行分隔，使得所有 小于<code>x</code> 的节点都出现在 大于或等于 <code>x</code> 的节点之前。你应当 保留 两个分区中每个节点的初始相对位置。</strong></p>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<p>示例1：<br><img src="https://assets.leetcode.com/uploads/2021/01/04/partition.jpg" alt="在这里插入图片描述"></p>
<blockquote>
<p>输入：head = [1,4,3,2,5,2], x = 3<br>输出：[1,2,2,4,3,5]</p>
</blockquote>
<p>示例2：</p>
<blockquote>
<p>输入：head = [2,1], x = 2<br>输出：[1,2]</p>
</blockquote>
<span id="more"></span>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<h3 id="方法一：分成两个链表"><a href="#方法一：分成两个链表" class="headerlink" title="方法一：分成两个链表"></a>方法一：分成两个链表</h3><p>自己的第一想法是将初始的链表分成两个满足题目条件的链表，然后再根据题目条件将这两个链表进行连接即可.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">partition</span><span class="params">(ListNode* head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        ListNode *l1=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode *l2=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        ListNode *cur1=l1;</span><br><span class="line">        ListNode *cur2=l2;</span><br><span class="line"></span><br><span class="line">        ListNode *cursor=head;</span><br><span class="line">        <span class="keyword">while</span>(cursor!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cursor-&gt;val &lt; x)&#123;</span><br><span class="line">                cur1-&gt;next=cursor;</span><br><span class="line">                cur1=cur1-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur2-&gt;next=cursor;</span><br><span class="line">                cur2=cur2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cursor=cursor-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur1-&gt;next=l2-&gt;next;</span><br><span class="line">        cur2-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> l1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<h3 id="方法二：自己再定义一个链表"><a href="#方法二：自己再定义一个链表" class="headerlink" title="方法二：自己再定义一个链表"></a>方法二：自己再定义一个链表</h3><p>将所有小于给定值的节点取出组成一个新的链表，此时原链表中剩余的节点的值都大于或等于给定值，只要将原链表直接接在新链表后即可<br>其实再想一下这道题的这个想法，也就是删除节点，只是被删除的结点需要放到另一个新的链表中，所以和之前做的<code>83. 删除排序链表中的重复元素</code>有一些类似之处，只是删除的结点操作不同而已<br>此种解法链表变化顺序为：</p>
<p>Original: 1 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 2 </p>
<p>New:</p>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>
 
<p>Original: 4 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 2 </p>
<p>New:　  1</p>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>
 
<p>Original: 4 -&gt; 3 -&gt; 5 -&gt; 2 </p>
<p>New:　  1 -&gt; 2</p>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<p>Original: 4 -&gt; 3 -&gt; 5 </p>
<p>New:　  1 -&gt; 2 -&gt; 2</p>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>
 
<p>Original: </p>
<p>New:　  1 -&gt; 2 -&gt; 2 -&gt; 4 -&gt; 3 -&gt; 5 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">partition</span><span class="params">(ListNode *head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        ListNode *newDummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line"></span><br><span class="line">        ListNode *cur = dummy, *p = newDummy;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;next-&gt;val &lt; x) &#123;</span><br><span class="line">			<span class="comment">//除了删除结点的那步，其余的三步骤都是对被删除结点的特殊操作</span></span><br><span class="line">                p-&gt;next = cur-&gt;next;				</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next;		<span class="comment">//这是相当于删除结点的关键步骤</span></span><br><span class="line">                p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;next = dummy-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> newDummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<h3 id="方法三：移动结点"><a href="#方法三：移动结点" class="headerlink" title="方法三：移动结点"></a>方法三：移动结点</h3><p>这道题要求我们划分链表，把所有小于给定值的节点都移到前面，大于该值的节点顺序不变，相当于一个局部排序的问题。那么可以想到的一种解法是首先找到第一个大于或等于给定值的节点，用题目中给的例子来说就是先找到4，然后再找小于3的值，每找到一个就将其取出置于4之前即可</p>
<pre><code>dummy 
  *    -    1    |-    4    -    3    -    2    -    5    -    nullptr
            pre                 cur        tmp                            
(pre-&gt;next-&gt;val &gt; x                cur-&gt;next-&gt;val &lt; x)

变成

dummy 
  *    -    1    -    2    |-    4    -    3    -    5    -    nullptr
                    pre/tmp               cur                
</code></pre>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">partition</span><span class="params">(ListNode *head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        ListNode *pre = dummy, *cur = head;;</span><br><span class="line">        <span class="keyword">while</span> (pre-&gt;next &amp;&amp; pre-&gt;next-&gt;val &lt; x) pre = pre-&gt;next;</span><br><span class="line">        cur = pre;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;next-&gt;val &lt; x) &#123;</span><br><span class="line">                ListNode *tmp = cur-&gt;next;</span><br><span class="line">                cur-&gt;next = tmp-&gt;next;</span><br><span class="line">                tmp-&gt;next = pre-&gt;next;</span><br><span class="line">                pre-&gt;next = tmp;</span><br><span class="line">                pre = pre-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>61. 旋转链表</title>
    <url>/2021/06/09/LeetCode/LeetCode_20210609/</url>
    <content><![CDATA[<blockquote>
<p>参考链接：</p>
<ol>
<li><a href="https://leetcode-cn.com/problems/rotate-list/submissions/">https://leetcode-cn.com/problems/rotate-list/submissions/</a></li>
<li><a href="https://www.cnblogs.com/grandyang/p/4355505.html">https://www.cnblogs.com/grandyang/p/4355505.html</a></li>
</ol>
</blockquote>
<h5 id="给你一个链表的头节点-head-，旋转链表，将链表每个节点向右移动-k-个位置。"><a href="#给你一个链表的头节点-head-，旋转链表，将链表每个节点向右移动-k-个位置。" class="headerlink" title="给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。"></a>给你一个链表的头节点 <code>head</code> ，旋转链表，将链表每个节点向右移动 k 个位置。</h5><p><img src="https://img-blog.csdnimg.cn/img_convert/192699c8d11d5f13a4f06fdf4823fd2e.png#pic_center" alt="在这里插入图片描述"></p>
<blockquote>
<p>输入：head = [1,2,3,4,5], k = 2<br>输出：[4,5,1,2,3]</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/img_convert/98af10b6c9f0f827ddb34c07b83e40c6.png#pic_center" alt="在这里插入图片描述"></p>
<blockquote>
<p>输入：head = [0,1,2], k = 4<br>输出：[2,0,1]</p>
</blockquote>
<span id="more"></span>

<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<p>一般第一想法就是使用快慢指针，通过将链表分成两部分，再重新连接链表达到旋转的效果，使用快慢指针时注意有些坑：<br>&emsp; （1）这题旋转的位置可能会大于链表长度，所以通过测出链表长度，再取余得到具体旋转位置；<br>&emsp; （2）将两段链表连接时，快慢指针分别应处于什么位置，这是需要自己在草稿纸上模拟下，确定连接时的操作。</p>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<blockquote>
<p>方法1：快慢指针</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>||head-&gt;next==<span class="literal">nullptr</span>||k==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        ListNode *root=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        root-&gt;next=head;</span><br><span class="line"></span><br><span class="line">        ListNode *cursor=head;</span><br><span class="line">        <span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cursor!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            n++;</span><br><span class="line">            cursor=cursor-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;n&lt;&lt;endl;		//测试链表的长度是否正确，第一次自己写的时候就出错了</span></span><br><span class="line">        n=k%n;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;n&lt;&lt;endl;</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//下面这个就保证了旋转的位置一定是在链表中的某个结合处，排除了旋转踏步（虽然k&gt;0，但仍不旋转）的情况</span></span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        ListNode *slow=head,*fast=head;</span><br><span class="line">        <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">            fast=fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">            fast=fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        root-&gt;next=slow-&gt;next;</span><br><span class="line">        fast-&gt;next=head;</span><br><span class="line">        slow-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*或者可以这样写，可以减少root结点的定义</span></span><br><span class="line"><span class="comment">        fast-&gt;next = head;</span></span><br><span class="line"><span class="comment">        fast = slow-&gt;next;</span></span><br><span class="line"><span class="comment">        slow-&gt;next = NULL;</span></span><br><span class="line"><span class="comment">        return fast;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*被各种特殊情况打败 或 超出时间限制*/</span></span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>||head-&gt;next==<span class="literal">nullptr</span>||k==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        ListNode *root=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        root-&gt;next=head;</span><br><span class="line">        ListNode *slow=head,*fast=head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(k--)&#123;         <span class="comment">//为了让快指针走到正确的位置不如直接测长度，然后再具体定位</span></span><br><span class="line">            fast=fast-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                fast=head;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fast==slow)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">            fast=fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        root-&gt;next=slow-&gt;next;</span><br><span class="line">        fast-&gt;next=head;</span><br><span class="line">        slow-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root-&gt;next;</span><br><span class="line">*/</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<blockquote>
<p>方法2：使链表变成循环链表，然后在具体的旋转位置处断开。喵啊~（见第二个参考链接的方法二）</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">rotateRight</span><span class="params">(ListNode *head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">        ListNode *cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next) &#123;</span><br><span class="line">            ++n;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = head;</span><br><span class="line">        <span class="keyword">int</span> m = n - k % n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *newhead = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> newhead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>147. 对链表进行插入排序</title>
    <url>/2021/06/15/LeetCode/LeetCode_20210615/</url>
    <content><![CDATA[<blockquote>
<p>参考链接： </p>
<ol>
<li><a href="https://leetcode-cn.com/problems/insertion-sort-list/solution/dui-lian-biao-jin-xing-cha-ru-pai-xu-by-leetcode-s/">https://leetcode-cn.com/problems/insertion-sort-list/solution/dui-lian-biao-jin-xing-cha-ru-pai-xu-by-leetcode-s/</a></li>
<li><a href="https://grandyang.com/leetcode/147/">https://grandyang.com/leetcode/147/</a></li>
</ol>
</blockquote>
<p>对链表进行插入排序。</p>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<p>示例1：</p>
<blockquote>
<p>输入: 4-&gt;2-&gt;1-&gt;3<br>输出: 1-&gt;2-&gt;3-&gt;4</p>
</blockquote>
<p>示例2：</p>
<blockquote>
<p>输入: -1-&gt;5-&gt;3-&gt;4-&gt;0<br>输出: -1-&gt;0-&gt;3-&gt;4-&gt;5</p>
</blockquote>
<span id="more"></span>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<h3 id="方法一：分成两个链表，后面链表的节点依次插入前面链表中"><a href="#方法一：分成两个链表，后面链表的节点依次插入前面链表中" class="headerlink" title="方法一：分成两个链表，后面链表的节点依次插入前面链表中"></a>方法一：分成两个链表，后面链表的节点依次插入前面链表中</h3><p>一个元素一个元素的从原链表中取出来，然后按顺序插入到新链表中，时间复杂度为 O(n2)，是一种效率并不是很高的算法，但是空间复杂度为 O(1)，以高时间复杂度换取了低空间复杂度<br><img src="/images/LeetCode_147_1.jpg"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">insertionSortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//注意开始并没有连接头节点，依然是将其分成两个链表</span></span><br><span class="line">		<span class="comment">//将后一个链表依次插入到前一个链表当中</span></span><br><span class="line">        ListNode* dummy=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);		</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(head) &#123;</span><br><span class="line">            ListNode* tmp=head-&gt;next; </span><br><span class="line">            ListNode* cursor=dummy;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//遍历查找插入位置</span></span><br><span class="line">            <span class="keyword">while</span>(cursor-&gt;next!=<span class="literal">nullptr</span> &amp;&amp; cursor-&gt;next-&gt;val &lt; head-&gt;val) &#123;</span><br><span class="line">                cursor=cursor-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//找到后进行插入</span></span><br><span class="line">			<span class="comment">//开始第一个节点，因为cursor==dummy，所以第一次插入cursor-&gt;next是为nullptr</span></span><br><span class="line">			<span class="comment">//接下来插入就是依次插入节点到第一个链表中了</span></span><br><span class="line">            head-&gt;next=cursor-&gt;next;</span><br><span class="line">            cursor-&gt;next=head;</span><br><span class="line">            head=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<h3 id="方法二：从前往后找插入点"><a href="#方法二：从前往后找插入点" class="headerlink" title="方法二：从前往后找插入点"></a>方法二：从前往后找插入点</h3><img src="/images/LeetCode_147_2.jpg">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">insertionSortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) </span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//lastSorted标志的是前面已经排好序链表的最后一个节点</span></span><br><span class="line">        <span class="comment">//和上面的方法不同是这个链表没有断</span></span><br><span class="line">        ListNode* lastSorted = head;</span><br><span class="line">        ListNode* cursor = head-&gt;next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (cursor) &#123;</span><br><span class="line">            <span class="comment">//如果比排好序的最后一个节点值还大，就老老实实在最后面吧</span></span><br><span class="line">            <span class="keyword">if</span> (lastSorted-&gt;val &lt;= cursor-&gt;val) &#123;</span><br><span class="line">                lastSorted = lastSorted-&gt;next;</span><br><span class="line">            &#125; </span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ListNode *prev = dummy;</span><br><span class="line">                <span class="keyword">while</span> (prev-&gt;next-&gt;val &lt;= cursor-&gt;val) &#123;</span><br><span class="line">                    prev = prev-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                lastSorted-&gt;next = cursor-&gt;next;</span><br><span class="line">                cursor-&gt;next = prev-&gt;next;</span><br><span class="line">                prev-&gt;next = cursor;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cursor = lastSorted-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>328. 奇偶链表</title>
    <url>/2021/06/14/LeetCode/LeetCode_20210614/</url>
    <content><![CDATA[<blockquote>
<p>参考链接： </p>
<ol>
<li><a href="https://leetcode-cn.com/problems/odd-even-linked-list/solution/qi-ou-lian-biao-by-leetcode-solution/">https://leetcode-cn.com/problems/odd-even-linked-list/solution/qi-ou-lian-biao-by-leetcode-solution/</a></li>
<li><a href="https://grandyang.com/leetcode/328/">https://grandyang.com/leetcode/328/</a></li>
</ol>
</blockquote>
<p>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</p>
<p>请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。</p>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<p>示例1：</p>
<blockquote>
<p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL</p>
</blockquote>
<p>示例2：</p>
<blockquote>
<p>输入: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL<br>输出: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL</p>
</blockquote>
<span id="more"></span>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<h3 id="方法一：设立两个只指向末尾的指针"><a href="#方法一：设立两个只指向末尾的指针" class="headerlink" title="方法一：设立两个只指向末尾的指针"></a>方法一：设立两个只指向末尾的指针</h3><p>如下图所示，<br><img src="/images/LeetCode_328_1.jpg"><br>其中可以发现， <code>slow</code> 指向已经排好序的奇数链表的最后一个节点， <code>fast</code> 指向已经排好序的偶数链表的最后一个节点，之后根据规律排后面的节点即可。</p>
<p>再发现可以看出，tmp1一直指向已经排好序的偶数链表的第一个节点，所以可以直接设立个节点，就不用每次都要创建了；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">oddEvenList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head||!head-&gt;next||!head-&gt;next-&gt;next)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        ListNode *slow=head,*fast=head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(fast&amp;&amp;fast-&gt;next)&#123;</span><br><span class="line">            ListNode *tmp1=slow-&gt;next,*tmp2=fast-&gt;next;</span><br><span class="line">            slow-&gt;next=tmp2;</span><br><span class="line">            fast-&gt;next=tmp2-&gt;next;</span><br><span class="line">            tmp2-&gt;next=tmp1;</span><br><span class="line"></span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">            fast=fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		//写法2：</span></span><br><span class="line"><span class="comment">        if (!head || !head-&gt;next) return head;</span></span><br><span class="line"><span class="comment">        ListNode *pre = head, *cur = head-&gt;next;</span></span><br><span class="line"><span class="comment">        while (cur &amp;&amp; cur-&gt;next) &#123;</span></span><br><span class="line"><span class="comment">            ListNode *tmp = pre-&gt;next;</span></span><br><span class="line"><span class="comment">            pre-&gt;next = cur-&gt;next;</span></span><br><span class="line"><span class="comment">            cur-&gt;next = cur-&gt;next-&gt;next;</span></span><br><span class="line"><span class="comment">            pre-&gt;next-&gt;next = tmp;</span></span><br><span class="line"><span class="comment">            cur = cur-&gt;next;</span></span><br><span class="line"><span class="comment">            pre = pre-&gt;next;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return head;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		//写法3：</span></span><br><span class="line"><span class="comment">		if (head == nullptr) &#123;</span></span><br><span class="line"><span class="comment">            return head;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        ListNode* evenHead = head-&gt;next;</span></span><br><span class="line"><span class="comment">        ListNode* odd = head;</span></span><br><span class="line"><span class="comment">        ListNode* even = evenHead;</span></span><br><span class="line"><span class="comment">        while (even != nullptr &amp;&amp; even-&gt;next != nullptr) &#123;</span></span><br><span class="line"><span class="comment">            odd-&gt;next = even-&gt;next;</span></span><br><span class="line"><span class="comment">            odd = odd-&gt;next;</span></span><br><span class="line"><span class="comment">            even-&gt;next = odd-&gt;next;</span></span><br><span class="line"><span class="comment">            even = even-&gt;next;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        odd-&gt;next = evenHead;</span></span><br><span class="line"><span class="comment">        return head;</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<h3 id="方法二：设立两个指向排好序的头指针"><a href="#方法二：设立两个指向排好序的头指针" class="headerlink" title="方法二：设立两个指向排好序的头指针"></a>方法二：设立两个指向排好序的头指针</h3><p>还有一种解法，用两个奇偶指针分别指向奇偶节点的起始位置，另外需要一个单独的指针even_head来保存偶节点的起点位置，然后把奇节点的指向偶节点的下一个(一定是奇节点)，此奇节点后移一步，再把偶节点指向下一个奇节点的下一个(一定是偶节点)，此偶节点后移一步，以此类推直至末尾，此时把分开的偶节点的链表连在奇节点的链表后即可<br><img src="/images/LeetCode_328_2.jpg"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">oddEvenList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *odd = head, *even = head-&gt;next, *even_head = even;</span><br><span class="line">        <span class="keyword">while</span> (even &amp;&amp; even-&gt;next) &#123;</span><br><span class="line">            odd-&gt;next = even-&gt;next;</span><br><span class="line">			odd = odd-&gt;next;</span><br><span class="line">            even-&gt;next = odd-&gt;next;</span><br><span class="line">			even = even-&gt;next;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*还可以合并起来</span></span><br><span class="line"><span class="comment">			odd = odd-&gt;next = even-&gt;next;</span></span><br><span class="line"><span class="comment">            even = even-&gt;next = odd-&gt;next;</span></span><br><span class="line"><span class="comment">			*/</span></span><br><span class="line">        &#125;</span><br><span class="line">        odd-&gt;next = even_head;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>82. 删除排序链表中的重复元素 II</title>
    <url>/2021/06/16/LeetCode/LeetCode_20210616/</url>
    <content><![CDATA[<blockquote>
<p>参考链接： </p>
<ol>
<li><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/solution/shan-chu-pai-xu-lian-biao-zhong-de-zhong-oayn/">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/solution/shan-chu-pai-xu-lian-biao-zhong-de-zhong-oayn/</a></li>
<li><a href="https://grandyang.com/leetcode/82/">https://grandyang.com/leetcode/82/</a></li>
</ol>
</blockquote>
<p>存在一个按升序排列的链表，给你这个链表的头节点 <code>head</code> ，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中 <strong>没有重复出现</strong> 的数字。</p>
<p>返回同样按升序排列的结果链表。</p>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<p>示例1：<br><img src="https://assets.leetcode.com/uploads/2021/01/04/linkedlist1.jpg" alt="在这里插入图片描述"></p>
<blockquote>
<p>输入：head = [1,2,3,3,4,4,5]<br>输出：[1,2,5]</p>
</blockquote>
<p>示例2：<br><img src="https://assets.leetcode.com/uploads/2021/01/04/linkedlist2.jpg" alt="在这里插入图片描述"></p>
<blockquote>
<p>输入：head = [1,1,1,2,3]<br>输出：[2,3]</p>
</blockquote>
<span id="more"></span>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *dummy=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummy-&gt;next=head;</span><br><span class="line"></span><br><span class="line">        ListNode *cursor=dummy;</span><br><span class="line">        <span class="comment">//为什么下面循环条件要写成cursor-&gt;next &amp;&amp; cursor-&gt;next-&gt;next，而不是 cursor-&gt;next-&gt;next</span></span><br><span class="line">        <span class="comment">//因为如果出现[1,1]情况，头节点dummy后面一个节点会出现空节点，这样，dummy(cursor)-&gt;next-&gt;next就是错误写法，而且要使用cursor-&gt;next-&gt;next的值，所以如果cursor-&gt;next-&gt;next为空，cursor-&gt;next-&gt;next-&gt;val就是错误的</span></span><br><span class="line">        <span class="keyword">while</span>(cursor-&gt;next &amp;&amp; cursor-&gt;next-&gt;next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cursor-&gt;next-&gt;val==cursor-&gt;next-&gt;next-&gt;val)&#123;</span><br><span class="line">                <span class="keyword">int</span> x=cursor-&gt;next-&gt;val;</span><br><span class="line">                <span class="keyword">while</span>(cursor-&gt;next &amp;&amp; cursor-&gt;next-&gt;val==x)&#123;        <span class="comment">//注意不要忘了cursor-&gt;next的条件，有可能最后几个节点都是重复节点</span></span><br><span class="line">                    cursor-&gt;next=cursor-&gt;next-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cursor=cursor-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>), *pre = dummy;</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        <span class="keyword">while</span> (pre-&gt;next) &#123;</span><br><span class="line">            ListNode *cur = pre-&gt;next;</span><br><span class="line">            <span class="keyword">while</span> (cur-&gt;next &amp;&amp; cur-&gt;next-&gt;val == cur-&gt;val) &#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur != pre-&gt;next) pre-&gt;next = cur-&gt;next;</span><br><span class="line">            <span class="keyword">else</span> pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>142. 环形链表 II</title>
    <url>/2021/06/17/LeetCode/LeetCode_20210617/</url>
    <content><![CDATA[<blockquote>
<p>参考链接： </p>
<ol>
<li><a href="https://leetcode-cn.com/problems/linked-list-cycle/solution/huan-xing-lian-biao-by-leetcode-solution/">https://leetcode-cn.com/problems/linked-list-cycle/solution/huan-xing-lian-biao-by-leetcode-solution/</a></li>
<li><a href="https://grandyang.com/leetcode/141/">https://grandyang.com/leetcode/141/</a></li>
</ol>
</blockquote>
<p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p><strong>进阶</strong> ：你能用 O(1)（即，常量）内存解决此问题吗？</p>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<p>示例1：<br><img src="/images/LeetCode_141_1.png"></p>
<blockquote>
<p>输入：head = [3,2,0,-4], pos = 1<br>输出：返回索引为 1 的链表节点<br>解释：链表中有一个环，其尾部连接到第二个节点。</p>
</blockquote>
<p>示例2：<br><img src="/images/LeetCode_141_2.png"></p>
<blockquote>
<p>输入：head = [1,2], pos = 0<br>输出：返回索引为 0 的链表节点<br>解释：链表中有一个环，其尾部连接到第一个节点。</p>
</blockquote>
<p>示例3：<br><img src="/images/LeetCode_141_3.png"></p>
<blockquote>
<p>输入：head = [1], pos = -1<br>输出：返回 null<br>解释：链表中没有环。</p>
</blockquote>
<span id="more"></span>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<h3 id="方法一-哈希表"><a href="#方法一-哈希表" class="headerlink" title="方法一:哈希表"></a>方法一:哈希表</h3><p>一个非常直观的思路是：我们遍历链表中的每个节点，并将它记录下来；一旦遇到了此前遍历过的节点，就可以判定链表中存在环。借助哈希表可以很方便地实现。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;ListNode *&gt; visited;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited.<span class="built_in">count</span>(head)) &#123;</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            &#125;</span><br><span class="line">            visited.<span class="built_in">insert</span>(head);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<h3 id="方法二：快慢指针"><a href="#方法二：快慢指针" class="headerlink" title="方法二：快慢指针"></a>方法二：快慢指针</h3><p>fast 与 slow起始都位于链表的头部。如下图所示，紫色点为相遇点。<br><img src="/images/LeetCode_142.png"><br>相遇时，fast 指针已经走完了环的 n 圈，因此它走过的总距离为 a+n(b+c)+b=a+(n+1)b+nc。<br>根据题意，任意时刻，fast 指针走过的距离都为  指针的 2 倍。因此，我们有<br>a+(n+1)b+nc=2(a+b) ⟹ a=c+(n−1)(b+c)<br>从上式中，可以发现：从相遇点到入环点的距离加上 n-1 圈的环长c+(n-1)(b+c)，恰好等于从链表头部到入环点的距离a。<br>因此，当发现 slow 与 fast 相遇时，我们再额外使用一个指针 ptr。起始，它指向链表头部；随后，它和 slow 每次向后移动一个位置。最终，它们会在入环点相遇。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *slow = head, *fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line"></span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">                ListNode *ptr = head;</span><br><span class="line">                <span class="keyword">while</span> (ptr != slow) &#123;</span><br><span class="line">                    ptr = ptr-&gt;next;</span><br><span class="line">                    slow = slow-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		//不同写法一</span></span><br><span class="line"><span class="comment">		ListNode *slow = head, *fast = head;</span></span><br><span class="line"><span class="comment">        while (fast != nullptr) &#123;</span></span><br><span class="line"><span class="comment">            slow = slow-&gt;next;</span></span><br><span class="line"><span class="comment">            if (fast-&gt;next == nullptr) &#123;</span></span><br><span class="line"><span class="comment">                return nullptr;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            fast = fast-&gt;next-&gt;next;</span></span><br><span class="line"><span class="comment">            if (fast == slow) &#123;</span></span><br><span class="line"><span class="comment">                ListNode *ptr = head;</span></span><br><span class="line"><span class="comment">                while (ptr != slow) &#123;</span></span><br><span class="line"><span class="comment">                    ptr = ptr-&gt;next;</span></span><br><span class="line"><span class="comment">                    slow = slow-&gt;next;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                return ptr;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return nullptr;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		//不同写法二：</span></span><br><span class="line"><span class="comment">		class Solution &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    ListNode *detectCycle(ListNode *head) &#123;</span></span><br><span class="line"><span class="comment">        ListNode *slow = head, *fast = head;</span></span><br><span class="line"><span class="comment">        while (fast &amp;&amp; fast-&gt;next) &#123;</span></span><br><span class="line"><span class="comment">            slow = slow-&gt;next;</span></span><br><span class="line"><span class="comment">            fast = fast-&gt;next-&gt;next;</span></span><br><span class="line"><span class="comment">            if (slow == fast) break;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        if (!fast || !fast-&gt;next) return NULL;</span></span><br><span class="line"><span class="comment">        slow = head;</span></span><br><span class="line"><span class="comment">        while (slow != fast) &#123;</span></span><br><span class="line"><span class="comment">            slow = slow-&gt;next;</span></span><br><span class="line"><span class="comment">            fast = fast-&gt;next;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return fast;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>2. 两数相加</title>
    <url>/2021/06/18/LeetCode/LeetCode_20210618/</url>
    <content><![CDATA[<blockquote>
<p>参考链接：</p>
<ol>
<li><a href="https://leetcode-cn.com/problems/add-two-numbers/">https://leetcode-cn.com/problems/add-two-numbers/</a></li>
<li><a href="https://grandyang.com/leetcode/2/">https://grandyang.com/leetcode/2/</a></li>
</ol>
</blockquote>
<p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<p>示例1：<br><img src="/images/LeetCode_2.jpg"></p>
<blockquote>
<p>输入：l1 = [2,4,3], l2 = [5,6,4]<br>输出：[7,0,8]<br>解释：342 + 465 = 807</p>
</blockquote>
<p>示例2：</p>
<blockquote>
<p>输入：l1 = [0], l2 = [0]<br>输出：[0]</p>
</blockquote>
<p>示例3：</p>
<blockquote>
<p>输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]<br>输出：[8,9,9,9,0,0,0,1]</p>
</blockquote>
<span id="more"></span>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>


<h3 id="方法一：while循环条件为：l1-l2"><a href="#方法一：while循环条件为：l1-l2" class="headerlink" title="方法一：while循环条件为：l1||l2"></a>方法一：while循环条件为：l1||l2</h3><p>需要在循环之后对进位carry进行判断</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode *head=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode *cursor=head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> carry=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1||l2)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum=(l1?l1-&gt;val:<span class="number">0</span>)+(l2?l2-&gt;val:<span class="number">0</span>)+carry;</span><br><span class="line">            carry=sum/<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">            cursor-&gt;next=<span class="keyword">new</span> <span class="built_in">ListNode</span>(sum%<span class="number">10</span>);</span><br><span class="line">            cursor=cursor-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(l1) l1=l1-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(l2) l2=l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry&gt;<span class="number">0</span>) </span><br><span class="line">            cursor-&gt;next=<span class="keyword">new</span> <span class="built_in">ListNode</span>(carry);	<span class="comment">//也可以写成cursor-&gt;next=new ListNode(1);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">        ListNode *head=nullptr;</span></span><br><span class="line"><span class="comment">	ListNode *cursor=head;</span></span><br><span class="line"><span class="comment">        int carry=0;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        while(l1||l2)&#123;</span></span><br><span class="line"><span class="comment">            int n1=l1?l1-&gt;val:0;</span></span><br><span class="line"><span class="comment">            int n2=l2?l2-&gt;val:0;</span></span><br><span class="line"><span class="comment">            int sum=n1+n2+carry;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            if(!head)&#123;</span></span><br><span class="line"><span class="comment">                //因为是第一个节点，所以head和tail的操作相同</span></span><br><span class="line"><span class="comment">                //当然可以在结果返回head-&gt;next，直接不用这个分支</span></span><br><span class="line"><span class="comment">                head=cursor=new ListNode(sum%10);</span></span><br><span class="line"><span class="comment">            &#125;else&#123;</span></span><br><span class="line"><span class="comment">                cursor-&gt;next=new ListNode(sum%10);</span></span><br><span class="line"><span class="comment">                cursor=cursor-&gt;next;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            carry=sum/10;</span></span><br><span class="line"><span class="comment">            if(l1) l1=l1-&gt;next;</span></span><br><span class="line"><span class="comment">            if(l2) l2=l2-&gt;next;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        if(carry&gt;0)&#123;</span></span><br><span class="line"><span class="comment">            cursor-&gt;next=new ListNode(carry);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        return head;	//注意这里返回的节点不同，所以在创建第一个节点也和第一种写法不同</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">		</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<h3 id="方法二：while循环条件为：l1-l2-carry-0"><a href="#方法二：while循环条件为：l1-l2-carry-0" class="headerlink" title="方法二：while循环条件为：l1||l2||carry!=0"></a>方法二：while循环条件为：l1||l2||carry!=0</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ListNode *head=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode *cursor=head;</span><br><span class="line">        <span class="keyword">int</span> carry=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="literal">nullptr</span> || l2!=<span class="literal">nullptr</span> ||carry!=<span class="number">0</span>)&#123;       <span class="comment">//注意跳出循环条件</span></span><br><span class="line">            <span class="keyword">int</span> sum = (l1?l1-&gt;val:<span class="number">0</span>)+(l2?l2-&gt;val:<span class="number">0</span>)+carry;</span><br><span class="line"></span><br><span class="line">            cursor-&gt;next=<span class="keyword">new</span> <span class="built_in">ListNode</span>(sum%<span class="number">10</span>);      <span class="comment">//注意如何伸展出新的链表部分</span></span><br><span class="line">            cursor=cursor-&gt;next;</span><br><span class="line"></span><br><span class="line">            carry=sum/<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(l1!=<span class="literal">nullptr</span>) l1=l1-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(l2!=<span class="literal">nullptr</span>) l2=l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>237. 删除链表中的节点</title>
    <url>/2021/06/20/LeetCode/LeetCode_20210620/</url>
    <content><![CDATA[<blockquote>
<p>参考链接：</p>
<ol>
<li><a href="https://leetcode-cn.com/problems/rotate-list/submissions/">https://leetcode-cn.com/problems/rotate-list/submissions/</a></li>
<li><a href="https://www.cnblogs.com/grandyang/p/4355505.html">https://www.cnblogs.com/grandyang/p/4355505.html</a></li>
</ol>
</blockquote>
<p><strong>请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点。传入函数的唯一参数为 <code>要被删除的节点</code> 。</strong></p>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<p>现有一个链表 – head = [4,5,1,9]，它可以表示为:</p>
<img src="/images/LeetCode_237.png">

<p>示例1：</p>
<blockquote>
<p>输入：head = [4,5,1,9], node = 5<br>输出：[4,1,9]<br>解释：给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</p>
</blockquote>
<p>示例2：</p>
<blockquote>
<p>输入：head = [4,5,1,9], node = 1<br>输出：[4,5,9]<br>解释：给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</p>
</blockquote>
<span id="more"></span>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<h3 id="方法：删除链表的节点（通过赋值下一节点的值来进行删除）"><a href="#方法：删除链表的节点（通过赋值下一节点的值来进行删除）" class="headerlink" title="方法：删除链表的节点（通过赋值下一节点的值来进行删除）"></a>方法：删除链表的节点（通过赋值下一节点的值来进行删除）</h3><p>自己的第一想法是将初始的链表分成两个满足题目条件的链表，然后再根据题目条件将这两个链表进行连接即可.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//在只给定被删除节点的情况下，删除该节点，并没有给出head结点</span></span><br><span class="line"></span><br><span class="line">        node-&gt;val=node-&gt;next-&gt;val;</span><br><span class="line">        node-&gt;next=node-&gt;next-&gt;next;</span><br><span class="line">		</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	注意另一种删除节点的方法是通过删除节点的前一节点辅助，使用了一个cursor-&gt;next</span></span><br><span class="line"><span class="comment">	而且注意while循环的判断条件，这在其他题目中也会遇到</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	ListNode *root=new ListNode(0);</span></span><br><span class="line"><span class="comment">        root-&gt;next=head;</span></span><br><span class="line"><span class="comment">        ListNode *cursor=root;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        while(cursor-&gt;next!=nullptr)&#123;</span></span><br><span class="line"><span class="comment">            if(cursor-&gt;next-&gt;val==node-&gt;val)&#123;</span></span><br><span class="line"><span class="comment">                cursor-&gt;next=cursor-&gt;next-&gt;next;</span></span><br><span class="line"><span class="comment">                return ;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            else</span></span><br><span class="line"><span class="comment">                cursor=cursor-&gt;next;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return ;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>234. 回文链表</title>
    <url>/2021/06/21/LeetCode/LeetCode_20210621/</url>
    <content><![CDATA[<blockquote>
<p>参考链接：</p>
<ol>
<li><a href="https://leetcode-cn.com/problems/rotate-list/submissions/">https://leetcode-cn.com/problems/rotate-list/submissions/</a></li>
<li><a href="https://www.cnblogs.com/grandyang/p/4355505.html">https://www.cnblogs.com/grandyang/p/4355505.html</a></li>
</ol>
</blockquote>
<p><strong>请判断一个链表是否为回文链表。</strong></p>
<p>示例1：</p>
<blockquote>
<p>输入: 1-&gt;2<br>输出: false</p>
</blockquote>
<p>示例2：</p>
<blockquote>
<p>输入: 1-&gt;2-&gt;2-&gt;1<br>输出: true</p>
</blockquote>
<p>进阶：<br>你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p>
<span id="more"></span>
<p>这道题让我们判断一个链表是否为回文链表，LeetCode 中关于回文串的题共有六道，除了这道，其他的五道为<br><a href="https://leetcode-cn.com/problems/palindrome-number/">9. 回文数</a>，<br><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">5. 最长回文子串</a>，<br><a href="https://leetcode-cn.com/problems/palindrome-partitioning">131. 分割回文串</a>，<br><a href="https://leetcode-cn.com/problems/palindrome-partitioning-ii">132. 分割回文串 II</a>，<br><a href="https://leetcode-cn.com/problems/valid-palindrome">125. 验证回文串</a>.</p>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<h3 id="方法一：分成两个链表，第二个链表再反转，对两个链表中的数据一一对比"><a href="#方法一：分成两个链表，第二个链表再反转，对两个链表中的数据一一对比" class="headerlink" title="方法一：分成两个链表，第二个链表再反转，对两个链表中的数据一一对比"></a>方法一：分成两个链表，第二个链表再反转，对两个链表中的数据一一对比</h3><p>自己的第一想法是将初始的链表分成两个链表，因为是回文链表，所以需要对第二个链表进行反转，然后再对两个链表的对应数据进行对比，得出结论<br>（至于如何对第二个链表进行反转，可以参考<code>206.反转链表</code>）.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>||head-&gt;next==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        ListNode* pre  = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        pre-&gt;next=head;</span><br><span class="line"></span><br><span class="line">        ListNode *slow=pre,*fast=pre;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="literal">nullptr</span> &amp;&amp; fast-&gt;next!=<span class="literal">nullptr</span>) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fast != <span class="literal">nullptr</span>) &#123;     <span class="comment">//偶数个</span></span><br><span class="line">            fast = slow-&gt;next;</span><br><span class="line">            slow-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">            fast=<span class="built_in">ReverseList</span>(fast);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(fast==<span class="literal">nullptr</span>) &#123;        <span class="comment">//奇数个</span></span><br><span class="line">            fast=slow-&gt;next;</span><br><span class="line">            slow=<span class="literal">nullptr</span>;</span><br><span class="line">            fast=<span class="built_in">ReverseList</span>(fast);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">nullptr</span>&amp;&amp;fast!=<span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(head-&gt;val!=fast-&gt;val) &#123;</span><br><span class="line">                <span class="comment">//cout&lt;&lt;head-&gt;val&lt;&lt;&quot;  &quot;&lt;&lt;fast-&gt;val&lt;&lt;endl;</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">            fast=fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">ReverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* cursor=head;</span><br><span class="line">        ListNode* pre=<span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cursor) &#123;</span><br><span class="line">            ListNode* NextNode=cursor-&gt;next;</span><br><span class="line">            cursor-&gt;next=pre;</span><br><span class="line">            pre=cursor;</span><br><span class="line">            cursor=NextNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<h3 id="方法二：使用栈的先进后出特性，进一半，验证另一半"><a href="#方法二：使用栈的先进后出特性，进一半，验证另一半" class="headerlink" title="方法二：使用栈的先进后出特性，进一半，验证另一半"></a>方法二：使用栈的先进后出特性，进一半，验证另一半</h3><p>（注意使用了栈，这时的空间复杂度不为o(1)）<br>链表比字符串难的地方就在于不能通过坐标来直接访问，而只能从头开始遍历到某个位置。那么根据回文串的特点，我们需要比较对应位置的值是否相等，一个非常直接的思路就是先按顺序把所有的结点值都存入到一个栈 stack 里，然后利用栈的后入先出的特性，就可以按顺序从末尾取出结点值了，此时再从头遍历一遍链表，就可以比较回文的对应位置了，若不同直接返回 false 即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *cur = head;</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(cur-&gt;val);</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = st.<span class="built_in">top</span>(); st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (head-&gt;val != t) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		//也可使用数组</span></span><br><span class="line"><span class="comment">        vector&lt;int&gt; v;</span></span><br><span class="line"><span class="comment">        while(head)&#123;</span></span><br><span class="line"><span class="comment">            v.push_back(head-&gt;val);</span></span><br><span class="line"><span class="comment">            head = head-&gt;next;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        // 判断是否回文</span></span><br><span class="line"><span class="comment">        for(int i=0; i&lt;v.size()/2; ++i)&#123;</span></span><br><span class="line"><span class="comment">            if(v[i] != v[v.size()-1-i])&#123;</span></span><br><span class="line"><span class="comment">                return false;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return true;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<h3 id="方法三："><a href="#方法三：" class="headerlink" title="方法三："></a>方法三：</h3><p>我们也可以用迭代的形式来实现，此时需要使用一个全局变量结点 cur，先初始化为头结点，可以有两种写法，一种写在函数外面的全局变量，或者是在递归函数的参数中加上引用，也表示使用的是全局变量。然后对头结点调用递归函数，在递归函数中，首先判空，若为空则直接返回 true，否则就对下一个结点调用递归函数，若递归函数返回 true 且同时再当前结点值跟 cur 的结点值相同的话，就表明是回文串，否则就不是，注意每次 cur 需要指向下一个结点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *cur = head;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(head, cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(ListNode* node, ListNode*&amp; cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">bool</span> res = <span class="built_in">helper</span>(node-&gt;next, cur) &amp;&amp; (cur-&gt;val == node-&gt;val);</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>


<h3 id="方法四："><a href="#方法四：" class="headerlink" title="方法四："></a>方法四：</h3><p>其实上面的两种解法重复比较一些结点，因为只要前半个链表和后半个链表对应值相等，就是一个回文链表，而并不需要再比较一遍后半个链表，所以我们可以找到链表的中点，这个可以用快慢指针来实现，使用方法可以参见之前的两篇 Convert Sorted List to Binary Search Tree 和 Reorder List，使用快慢指针找中点的原理是 fast 和 slow 两个指针，每次快指针走两步，慢指针走一步，等快指针走完时，慢指针的位置就是中点。我们还需要用栈，每次慢指针走一步，都把值存入栈中，等到达中点时，链表的前半段都存入栈中了，由于栈的后进先出的性质，就可以和后半段链表按照回文对应的顺序比较了，参见代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        ListNode *slow = head, *fast = head;</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; st&#123;&#123;head-&gt;val&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span> (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            st.<span class="built_in">push</span>(slow-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!fast-&gt;next) st.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">while</span> (slow-&gt;next) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">int</span> tmp = st.<span class="built_in">top</span>(); st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (tmp != slow-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
        <tag>回文串</tag>
      </tags>
  </entry>
  <entry>
    <title>206. 反转链表</title>
    <url>/2021/06/22/LeetCode/LeetCode_20210622/</url>
    <content><![CDATA[<blockquote>
<p>参考链接：</p>
<ol>
<li><a href="https://leetcode-cn.com/problems/rotate-list/submissions/">https://leetcode-cn.com/problems/rotate-list/submissions/</a></li>
<li><a href="https://www.cnblogs.com/grandyang/p/4355505.html">https://www.cnblogs.com/grandyang/p/4355505.html</a></li>
</ol>
</blockquote>
<p><strong>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</strong></p>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<p>示例1：<br><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="在这里插入图片描述"></p>
<blockquote>
<p>输入：head = [1,2,3,4,5]<br>输出：[5,4,3,2,1]</p>
</blockquote>
<p>示例2：<br><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg" alt="在这里插入图片描述"></p>
<blockquote>
<p>输入：head = [1,2]<br>输出：[2,1]</p>
</blockquote>
<p>示例3：</p>
<blockquote>
<p>输入：head = []<br>输出：[]</p>
</blockquote>
<p>进阶：链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p>
<span id="more"></span>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<h3 id="方法一：迭代"><a href="#方法一：迭代" class="headerlink" title="方法一：迭代"></a>方法一：迭代</h3><p>可以将该题转换为 两个链表，新建一个链表，然后从旧链表中依次取下头节点，然后当成新链表的头节点<br><img src="/images/LeetCode_206.jpg"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *newHead = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            ListNode *t = head-&gt;next;</span><br><span class="line">            head-&gt;next = newHead;</span><br><span class="line">            newHead = head;</span><br><span class="line">            head = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<h3 id="方法二：递归"><a href="#方法二：递归" class="headerlink" title="方法二：递归"></a>方法二：递归</h3><p>下面我们来看递归解法，代码量更少，递归解法的思路是，不断的进入递归函数，直到head指向倒数第二个节点，因为head指向空或者是最后一个结点都直接返回了，newHead则指向对head的下一个结点调用递归函数返回的头结点，此时newHead指向最后一个结点，然后head的下一个结点的next指向head本身，这个相当于把head结点移动到末尾的操作，因为是回溯的操作，所以head的下一个结点总是在上一轮被移动到末尾了，但head之后的next还没有断开，所以可以顺势将head移动到末尾，再把next断开，最后返回newHead即可，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *newHead = <span class="built_in">reverseList</span>(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>19. 删除链表的倒数第 N 个结点</title>
    <url>/2021/06/24/LeetCode/LeetCode_20210624/</url>
    <content><![CDATA[<blockquote>
<p>参考链接： </p>
<ol>
<li><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/solution/fan-zhuan-lian-biao-ii-by-leetcode-solut-teyq/">https://leetcode-cn.com/problems/reverse-linked-list-ii/solution/fan-zhuan-lian-biao-ii-by-leetcode-solut-teyq/</a></li>
<li><a href="https://grandyang.com/leetcode/92/">https://grandyang.com/leetcode/92/</a></li>
</ol>
</blockquote>
<p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p>
<p><strong>进阶</strong> ：你能尝试使用一趟扫描实现吗？</p>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<p>示例1：<br><img src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" alt="在这里插入图片描述"></p>
<blockquote>
<p>输入：head = [1,2,3,4,5], n = 2<br>输出：[1,2,3,5]</p>
</blockquote>
<p>示例2：</p>
<blockquote>
<p>输入：head = [1], n = 1<br>输出：[]</p>
</blockquote>
<p>示例3：</p>
<blockquote>
<p>输入：head = [1,2], n = 1<br>输出：[1]</p>
</blockquote>
<span id="more"></span>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<h3 id="方法"><a href="#方法" class="headerlink" title="方法:"></a>方法:</h3><p>可以想到一些特殊情况，例如会删除第一个节点或者最后一个节点，如果删除第一个节点，我们可以用dummy节点辅助，删除最后一个节点可以从最后一个节点的前一个节点，所以，采用cursor-&gt;next=cursor-&gt;next-&gt;next的方式删除节点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ListNode *dummy=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummy-&gt;next=head;</span><br><span class="line"></span><br><span class="line">        ListNode *fast=dummy,*slow=dummy;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            fast=fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            fast=fast-&gt;next;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        slow-&gt;next=slow-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>92. 反转链表 II</title>
    <url>/2021/06/23/LeetCode/LeetCode_20210623/</url>
    <content><![CDATA[<blockquote>
<p>参考链接： </p>
<ol>
<li><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/solution/fan-zhuan-lian-biao-ii-by-leetcode-solut-teyq/">https://leetcode-cn.com/problems/reverse-linked-list-ii/solution/fan-zhuan-lian-biao-ii-by-leetcode-solut-teyq/</a></li>
<li><a href="https://grandyang.com/leetcode/92/">https://grandyang.com/leetcode/92/</a></li>
</ol>
</blockquote>
<p>给你单链表的头指针 <code>head</code> 和两个整数 <code>left</code> 和 <code>right</code> ，其中 <code>left &lt;= right</code> 。请你反转从位置 <code>left</code> 到位置 <code>right</code> 的链表节点，返回 __反转后的链表 __ 。</p>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<p>示例1：<br><img src="https://assets.leetcode.com/uploads/2021/02/19/rev2ex2.jpg" alt="在这里插入图片描述"></p>
<blockquote>
<p>输入：head = [1,2,3,4,5], left = 2, right = 4<br>输出：[1,4,3,2,5]</p>
</blockquote>
<p>示例2：</p>
<blockquote>
<p>输入：head = [5], left = 1, right = 1<br>输出：[5]</p>
</blockquote>
<p>进阶： 你可以使用一趟扫描完成反转吗？</p>
<span id="more"></span>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<h3 id="方法一：穿针引线"><a href="#方法一：穿针引线" class="headerlink" title="方法一：穿针引线"></a>方法一：穿针引线</h3><p>使用「206. 反转链表」的解法，反转 left 到 right 部分以后，再拼接起来。我们还需要记录 left 的前一个节点，和 right 的后一个节点。链表的操作问题，一般而言面试（机试）的时候不允许我们修改节点的值，而只能修改节点的指向操作。</p>
<p>思路通常都不难，写对链表问题的技巧是：一定要先想清楚思路，并且必要的时候在草稿纸上画图，理清「穿针引线」的先后步骤，然后再编码。<br><img src="/images/LeetCode_92_1.jpg"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 因为头节点有可能发生变化，使用虚拟头节点可以避免复杂的分类讨论        </span></span><br><span class="line">        ListNode *dummy=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummy-&gt;next=head;</span><br><span class="line">        ListNode *pre=dummy;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第 1 步：从虚拟头节点走 left - 1 步，来到 left 节点的前一个节点</span></span><br><span class="line">        <span class="comment">// 建议写在 for 循环里，语义清晰</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;left;i++)&#123;</span><br><span class="line">            pre=pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第 2 步：从 pre 走到 right 节点</span></span><br><span class="line">        ListNode *l=pre-&gt;next,*r=pre-&gt;next;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;right-left;i++)&#123;</span><br><span class="line">            r=r-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第 3 步：切断出一个子链表（截取链表）</span></span><br><span class="line">        ListNode *post=r-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意：切断链接</span></span><br><span class="line">        pre-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">        r-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第 4 步：同第 206 题，反转链表的子区间</span></span><br><span class="line">        <span class="comment">//若是有返回节点的函数，应该写成r=reverseList(l);注意r在前面了</span></span><br><span class="line">        <span class="built_in">reverseList</span>(l);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第 5 步：接回到原来的链表中</span></span><br><span class="line">        <span class="comment">//***注意，反转链表后，r和l的位置调换了</span></span><br><span class="line">        pre-&gt;next=r;</span><br><span class="line">        l-&gt;next=post;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//反转链表</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *newHead = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            ListNode *t = head-&gt;next;</span><br><span class="line">            head-&gt;next = newHead;</span><br><span class="line">            newHead = head;</span><br><span class="line">            head = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<h3 id="方法二：一次遍历「穿针引线」反转链表（头插法）"><a href="#方法二：一次遍历「穿针引线」反转链表（头插法）" class="headerlink" title="方法二：一次遍历「穿针引线」反转链表（头插法）"></a>方法二：一次遍历「穿针引线」反转链表（头插法）</h3><p>对于链表的问题，根据以往的经验一般都是要建一个dummy node，连上原链表的头结点，这样的话就算头结点变动了，我们还可以通过dummy-&gt;next来获得新链表的头结点。这道题的要求是只通过一次遍历完成，就拿题目中的例子来说，变换的是2,3,4这三个点，我们需要找到第一个开始变换结点的前一个结点，只要让pre向后走m-1步即可，为啥要减1呢，因为题目中是从1开始计数的，这里只走了1步，就是结点1，用pre指向它。万一是结点1开始变换的怎么办，这就是我们为啥要用dummy结点了，pre也可以指向dummy结点。然后就要开始交换了，由于一次只能交换两个结点，所以我们按如下的交换顺序：</p>
<p>1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7-&gt; NULL</p>
<p>1 -&gt; 2 -&gt; 4 -&gt; 3 -&gt; 5 -&gt; 6 -&gt; 7-&gt; NULL</p>
<p>1 -&gt; 2 -&gt; 5 -&gt; 4 -&gt; 3 -&gt; 6 -&gt; 7-&gt; NULL</p>
<p>1 -&gt; 2 -&gt; 6 -&gt; 5 -&gt; 4 -&gt; 3 -&gt; 7-&gt; NULL</p>
<p>我们可以看出来，总共需要n-m步即可，<br>    第一步是将结点4放到结点2的后面，<br>    第二步将结点5放到结点2的后面，<br>    第二步将结点6放到结点2的后面，<br>这是很有规律的操作，那么我们就说一个就行了，比如刚开始，pre指向结点2，cur指向结点3，然后我们建立一个临时的结点tmp，指向结点4（注意我们用临时变量保存某个结点就是为了首先断开该结点和前面结点之间的联系，这可以当作一个规律记下来），然后我们断开结点3和结点4，将结点3的next连到结点5上，也就是 cur-&gt;next = tmp-&gt;next，再把结点4连到结点2的后面结点（即结点3）的前面，即 tmp-&gt;next = pre-&gt;next，最后再将原来的结点2和结点3的连接断开，将结点2连到结点4，即 pre-&gt;next = tmp。这样我们就完成了将结点4取出，加入结点2的后方。第二步也是同样的操作，这里就不多说了，请大家自己尝试下吧，参见代码如下：<br> <img src="/images/LeetCode_92_2.jpg"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">reverseBetween</span><span class="params">(ListNode *head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>), *pre = dummy;</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; ++i) pre = pre-&gt;next;</span><br><span class="line">        ListNode *cur = pre-&gt;next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &lt; n; ++i) &#123;</span><br><span class="line">            ListNode *t = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = t-&gt;next;</span><br><span class="line">            t-&gt;next = pre-&gt;next;</span><br><span class="line">            pre-&gt;next = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>141. 环形链表</title>
    <url>/2021/06/25/LeetCode/LeetCode_20210625/</url>
    <content><![CDATA[<blockquote>
<p>参考链接： </p>
<ol>
<li><a href="https://leetcode-cn.com/problems/linked-list-cycle/solution/huan-xing-lian-biao-by-leetcode-solution/">https://leetcode-cn.com/problems/linked-list-cycle/solution/huan-xing-lian-biao-by-leetcode-solution/</a></li>
<li><a href="https://grandyang.com/leetcode/141/">https://grandyang.com/leetcode/141/</a></li>
</ol>
</blockquote>
<p>给定一个链表，判断链表中是否有环。</p>
<p><strong>进阶</strong> ：你能用 O(1)（即，常量）内存解决此问题吗？</p>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<p>示例1：<br><img src="/images/LeetCode_141_1.png"></p>
<blockquote>
<p>输入：head = [3,2,0,-4], pos = 1<br>输出：true<br>解释：链表中有一个环，其尾部连接到第二个节点。</p>
</blockquote>
<p>示例2：<br><img src="/images/LeetCode_141_2.png"></p>
<blockquote>
<p>输入：head = [1,2], pos = 0<br>输出：true<br>解释：链表中有一个环，其尾部连接到第一个节点。</p>
</blockquote>
<p>示例3：<br><img src="/images/LeetCode_141_3.png"></p>
<blockquote>
<p>输入：head = [1], pos = -1<br>输出：false<br>解释：链表中没有环。</p>
</blockquote>
<span id="more"></span>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<h3 id="方法一-哈希表"><a href="#方法一-哈希表" class="headerlink" title="方法一:哈希表"></a>方法一:哈希表</h3><p>最容易想到的方法是遍历所有节点，每次遍历到一个节点时，判断该节点此前是否被访问过。</p>
<p>具体地，我们可以使用哈希表来存储所有已经访问过的节点。每次我们到达一个节点，如果该节点已经存在于哈希表中，则说明该链表是环形链表，否则就将该节点加入哈希表中。重复这一过程，直到我们遍历完整个链表即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;ListNode*&gt; seen;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (seen.<span class="built_in">count</span>(head)) &#123;	<span class="comment">//count函数的功能是：统计容器中等于value元素的个数，如果 &gt; 1,就有环</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            seen.<span class="built_in">insert</span>(head);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<h3 id="方法二：快慢指针"><a href="#方法二：快慢指针" class="headerlink" title="方法二：快慢指针"></a>方法二：快慢指针</h3><p>本方法需要读者对「Floyd 判圈算法」（又称龟兔赛跑算法）有所了解。</p>
<p>假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。</p>
<p>我们可以根据上述思路来解决本题。具体地，我们定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*if(head==nullptr||head-&gt;next==nullptr)</span></span><br><span class="line"><span class="comment">            return false;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        ListNode *fast=head-&gt;next,*slow=head;</span></span><br><span class="line"><span class="comment">        while(fast!=slow)&#123;//有环一定会跳出循环，无环就在循环内判断直接结束程序</span></span><br><span class="line"><span class="comment">            if(fast==nullptr||fast-&gt;next==nullptr)  //出现的情况是：两个都不成立或只有一个成立，成立就返回false</span></span><br><span class="line"><span class="comment">                return false;</span></span><br><span class="line"><span class="comment">            fast=fast-&gt;next-&gt;next;</span></span><br><span class="line"><span class="comment">            slow=slow-&gt;next;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return true;*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ListNode *fast=head,*slow=head;</span><br><span class="line">        <span class="keyword">while</span>(fast&amp;&amp;fast-&gt;next)&#123;    <span class="comment">//循环截至条件，如果写成||，那么一个成立依然可能会继续循环</span></span><br><span class="line">            fast=fast-&gt;next-&gt;next;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast==slow)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>876. 链表的中间结点</title>
    <url>/2021/06/26/LeetCode/LeetCode_20210626/</url>
    <content><![CDATA[<blockquote>
<p>参考链接： </p>
<ol>
<li><a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/solution/lian-biao-de-zhong-jian-jie-dian-by-leetcode-solut/">https://leetcode-cn.com/problems/middle-of-the-linked-list/solution/lian-biao-de-zhong-jian-jie-dian-by-leetcode-solut/</a></li>
</ol>
</blockquote>
<p>给定一个头结点为 <code>head</code> 的非空单链表，返回链表的中间结点。</p>
<p>如果有两个中间结点，则返回第二个中间结点。</p>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<p>示例1：</p>
<blockquote>
<p>输入：[1,2,3,4,5]<br>输出：返回的结点值为 3 </p>
</blockquote>
<p>示例2：</p>
<blockquote>
<p>输入：[1,2,3,4,5,6]<br>输出：由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。</p>
</blockquote>
<span id="more"></span>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<h3 id="方法一-数组"><a href="#方法一-数组" class="headerlink" title="方法一:数组"></a>方法一:数组</h3><p>链表的缺点在于不能通过下标访问对应的元素。因此我们可以考虑对链表进行遍历，同时将遍历到的元素依次放入数组 A 中。如果我们遍历到了 N 个元素，那么链表以及数组的长度也为 N，对应的中间节点即为 A[N/2]。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector&lt;ListNode*&gt; A = &#123;head&#125;;</span><br><span class="line">        <span class="keyword">while</span> (A.<span class="built_in">back</span>()-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">            A.<span class="built_in">push_back</span>(A.<span class="built_in">back</span>()-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> A[A.<span class="built_in">size</span>() / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<h3 id="方法二-单指针法"><a href="#方法二-单指针法" class="headerlink" title="方法二:单指针法"></a>方法二:单指针法</h3><p>我们可以对方法一进行空间优化，省去数组 A。</p>
<p>我们可以对链表进行两次遍历。第一次遍历时，我们统计链表中的元素个数 N；第二次遍历时，我们遍历到第 N/2 个元素（链表的首节点为第 0 个元素）时，将该元素返回即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ++n;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; n / <span class="number">2</span>) &#123;</span><br><span class="line">            ++k;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<h3 id="方法三：快慢指针"><a href="#方法三：快慢指针" class="headerlink" title="方法三：快慢指针"></a>方法三：快慢指针</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *fast=head,*slow=head;</span><br><span class="line">        <span class="keyword">while</span>(fast&amp;&amp;fast-&gt;next)&#123;</span><br><span class="line">            fast=fast-&gt;next-&gt;next;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>1. 两数之和</title>
    <url>/2021/07/06/LeetCode/LeetCode_20210706/</url>
    <content><![CDATA[<blockquote>
<p>参考链接： </p>
<ol>
<li><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/xiang-jiao-lian-biao-by-leetcode-solutio-a8jn/">https://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/xiang-jiao-lian-biao-by-leetcode-solutio-a8jn/</a></li>
<li><a href="https://grandyang.com/leetcode/1/">https://grandyang.com/leetcode/1/</a></li>
</ol>
</blockquote>
<p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code> ，请你在该数组中找出 <strong>和为目标值</strong> <code>target</code>  的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入 <strong>只会对应一个答案</strong> 。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。</p>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<p>示例1：</p>
<blockquote>
<p>输入：nums = [2,7,11,15], target = 9<br>输出：[0,1]<br>解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</p>
</blockquote>
<p>示例2：</p>
<blockquote>
<p>输入：nums = [3,2,4], target = 6<br>输出：[1,2]</p>
</blockquote>
<p>示例3：</p>
<blockquote>
<p>输入：nums = [3,3], target = 6<br>输出：[0,1]</p>
</blockquote>
<span id="more"></span>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<h3 id="方法一：暴力"><a href="#方法一：暴力" class="headerlink" title="方法一：暴力"></a>方法一：暴力</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;nums.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[j]==target)&#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;i,j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<h3 id="方法二：哈希表"><a href="#方法二：哈希表" class="headerlink" title="方法二：哈希表"></a>方法二：哈希表</h3><p>这道题还有一种特别巧妙的方法，虽然题目中强调了链表中不存在环，但是我们可以用环的思想来做，我们让两条链表分别从各自的开头开始往后遍历，当其中一条遍历到末尾时，我们跳到另一个条链表的开头继续遍历。两个指针最终会相等，而且只有两种情况，一种情况是在交点处相遇，另一种情况是在各自的末尾的空节点处相等。为什么一定会相等呢，因为两个指针走过的路程相同，是两个链表的长度之和，所以一定会相等。这个思路真的很巧妙，而且更重要的是代码写起来特别的简洁</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!headA || !headB) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *a = headA, *b = headB;</span><br><span class="line">        <span class="keyword">while</span> (a != b) &#123;</span><br><span class="line">            a = a ? a-&gt;next : headB;</span><br><span class="line">            b = b ? b-&gt;next : headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>160. 相交链表</title>
    <url>/2021/06/28/LeetCode/LeetCode_20210628/</url>
    <content><![CDATA[<blockquote>
<p>参考链接： </p>
<ol>
<li><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/xiang-jiao-lian-biao-by-leetcode-solutio-a8jn/">https://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/xiang-jiao-lian-biao-by-leetcode-solutio-a8jn/</a></li>
<li><a href="https://grandyang.com/leetcode/160/">https://grandyang.com/leetcode/160/</a></li>
</ol>
</blockquote>
<p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 <code>null</code> 。</p>
<p>图示两个链表在节点 <code>c1</code> 开始相交：<br><img src="/images/LeetCode_160.png"></p>
<p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p>
<p> <strong>注意</strong> ，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<p>示例1：<br><img src="/images/LeetCode_160_1.png"></p>
<blockquote>
<p>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3<br>输出：Intersected at ‘8’<br>解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。</p>
</blockquote>
<p>示例2：<br><img src="/images/LeetCode_160_2.png"></p>
<blockquote>
<p>输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1<br>输出：Intersected at ‘2’<br>解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。</p>
</blockquote>
<p>示例3：</p>
<blockquote>
<p>输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2<br>输出：null<br>解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。</p>
</blockquote>
<span id="more"></span>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<h3 id="方法一：消除链表长度差-依次对比"><a href="#方法一：消除链表长度差-依次对比" class="headerlink" title="方法一：消除链表长度差 + 依次对比"></a>方法一：消除链表长度差 + 依次对比</h3><p>如果两个链长度相同的话，那么对应的一个个比下去就能找到，所以只需要把长链表变短即可。具体算法为：分别遍历两个链表，得到分别对应的长度。然后求长度的差值，把较长的那个链表向后移动这个差值的个数，然后一一比较即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!headA||!headB)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> lenA=<span class="built_in">lengthList</span>(headA),lenB=<span class="built_in">lengthList</span>(headB);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(lenA&lt;lenB)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lenB-lenA;i++) headB=headB-&gt;next;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(lenA&gt;lenB)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lenA-lenB;i++) headA=headA-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(headA &amp;&amp; headB &amp;&amp; headA!=headB)&#123;</span><br><span class="line">            headA=headA-&gt;next;</span><br><span class="line">            headB=headB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (headA&amp;&amp;headB)?headA:<span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthList</span><span class="params">(ListNode *head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head)&#123;</span><br><span class="line">            len++;</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<h3 id="方法二：构成环"><a href="#方法二：构成环" class="headerlink" title="方法二：构成环"></a>方法二：构成环</h3><p>这道题还有一种特别巧妙的方法，虽然题目中强调了链表中不存在环，但是我们可以用环的思想来做，我们让两条链表分别从各自的开头开始往后遍历，当其中一条遍历到末尾时，我们跳到另一个条链表的开头继续遍历。两个指针最终会相等，而且只有两种情况，一种情况是在交点处相遇，另一种情况是在各自的末尾的空节点处相等。为什么一定会相等呢，因为两个指针走过的路程相同，是两个链表的长度之和，所以一定会相等。这个思路真的很巧妙，而且更重要的是代码写起来特别的简洁</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!headA || !headB) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *a = headA, *b = headB;</span><br><span class="line">        <span class="keyword">while</span> (a != b) &#123;</span><br><span class="line">            a = a ? a-&gt;next : headB;</span><br><span class="line">            b = b ? b-&gt;next : headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>15. 三数之和</title>
    <url>/2021/07/07/LeetCode/LeetCode_20210707/</url>
    <content><![CDATA[<blockquote>
<p>参考链接： </p>
<ol>
<li><a href="https://www.jianshu.com/p/69b0a1170f96">https://www.jianshu.com/p/69b0a1170f96</a></li>
<li><a href="https://www.cnblogs.com/grandyang/p/4481576.html">https://www.cnblogs.com/grandyang/p/4481576.html</a></li>
</ol>
</blockquote>
<p>给你一个包含 <code>n</code> 个整数的数组 <code>nums</code> ，判断 <code>nums</code> 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 <code>0</code> 且不重复的三元组。</p>
<p><strong>注意</strong> ：答案中不可以包含重复的三元组。</p>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<p>示例1：</p>
<blockquote>
<p>输入：nums = [-1,0,1,2,-1,-4]<br>输出：[[-1,-1,2],[-1,0,1]]</p>
</blockquote>
<p>示例2：</p>
<blockquote>
<p>输入：nums = []<br>输出：[]</p>
</blockquote>
<p>示例3：</p>
<blockquote>
<p>输入：nums = [0]<br>输出：[]</p>
</blockquote>
<span id="more"></span>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<h3 id="方法一：暴力-三重循环"><a href="#方法一：暴力-三重循环" class="headerlink" title="方法一：暴力 三重循环"></a>方法一：暴力 三重循环</h3><p>仅提供思路，时间复杂度o(n^3)，看下细节就行</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() &lt; <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; vec;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>()<span class="number">-2</span>;i++)&#123;               <span class="comment">//注意判断条件</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;nums.<span class="built_in">size</span>()<span class="number">-1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=j+<span class="number">1</span>;k&lt;nums.<span class="built_in">size</span>();k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(nums[i]+nums[j]+nums[k]==<span class="number">0</span>)&#123;</span><br><span class="line">                        vector&lt;<span class="keyword">int</span>&gt; v = &#123;nums[i],nums[j],nums[k]&#125;;</span><br><span class="line">                        <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>());</span><br><span class="line">                        <span class="keyword">if</span>(!<span class="built_in">count</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), v))&#123;</span><br><span class="line">                            vec.<span class="built_in">push_back</span>(v);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">		//三重循环其他写法</span></span><br><span class="line"><span class="comment">        sort(nums.begin(), nums.end());</span></span><br><span class="line"><span class="comment">        vector&lt;vector&lt;int&gt;&gt; result;</span></span><br><span class="line"><span class="comment">        if (nums.size() &lt; 3 || nums[0] &gt; 0 || nums[nums.size()-1] &lt; 0) </span></span><br><span class="line"><span class="comment">            return result;</span></span><br><span class="line"><span class="comment">            </span></span><br><span class="line"><span class="comment">        set&lt;vector&lt;int&gt;&gt; ret;</span></span><br><span class="line"><span class="comment">        for(int a=0; a&lt;nums.size()-2; a++)</span></span><br><span class="line"><span class="comment">            for(int b=a+1; b&lt;nums.size()-1; b++)</span></span><br><span class="line"><span class="comment">                for(int c=b+1; c&lt;nums.size(); c++)</span></span><br><span class="line"><span class="comment">                    if(nums[a]+nums[b]+nums[c]==0)&#123;</span></span><br><span class="line"><span class="comment">                        vector&lt;int&gt; vec = &#123;nums[a],nums[b],nums[c]&#125;;</span></span><br><span class="line"><span class="comment">                        sort(vec.begin(),vec.end());</span></span><br><span class="line"><span class="comment">                        ret.insert(vec);</span></span><br><span class="line"><span class="comment">                        //result.push_back(vec);</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        for(auto x:ret)</span></span><br><span class="line"><span class="comment">            result.push_back(x);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        return result;</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<h3 id="方法二：哈希表"><a href="#方法二：哈希表" class="headerlink" title="方法二：哈希表"></a>方法二：哈希表</h3><p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<h3 id="方法三：排序-双指针"><a href="#方法三：排序-双指针" class="headerlink" title="方法三：排序 + 双指针"></a>方法三：排序 + 双指针</h3><p>从第一题：两数之和中的两个方法暴力，哈希表都不能在时间限制内找到另外合适的两个数和，但是两数之和还有一题是167. 两数之和 II - 输入有序数组，不同的是这个数组是有序的，<br>而且使用双指针可以在o(n)时间内找到合适的两数之和，所以这题可以从排序入手。<br>第一步：排序</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">比如刚开始是[<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-4</span>]</span><br><span class="line">排序后变成是[<span class="number">-4</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<p>因为是要找到三数之和为0的数组，所以，对于已经排好序的数组来说，如果第一个为正数，那么有序是排好序的，所以后面两个也为正数。我们只需要遍历前面的负数和0，也就是&gt;0的我们统统不要了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>()<span class="number">-2</span>;i++)&#123;</span><br><span class="line">	<span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//nums[i]就是个负数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二步：双指针 找特定两数之和<br>拿到第一个负数后，我们只需要再拿到后面两个数，与之相加=0即可。后面两个数我们用两个指针来表示，j和k，一个是从左边往右边走，一个是从最右边往前走。有些思想就是想通的，之前的两数之和就是这种思路。先排好序，左边一个left指针，右边一个right指针，如果left+right &gt; result，那么right往左移，如果left+right &lt; result，那么说明相加得数不够，就需要left往右移。找到相加之和相等的就行。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> target=<span class="number">0</span>-nums[i];</span><br><span class="line">	<span class="keyword">int</span> j=i+<span class="number">1</span>,k=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span>(j&lt;k)&#123;</span><br><span class="line">		<span class="keyword">if</span>(nums[j]+nums[k]==target)&#123;</span><br><span class="line">			vec.<span class="built_in">push_back</span>(&#123;nums[i],nums[j],nums[k]&#125;);</span><br><span class="line">			<span class="keyword">while</span>(j&lt;k&amp;&amp;nums[j]==nums[j+<span class="number">1</span>]) j++;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;k&amp;&amp;nums[k]==nums[k<span class="number">-1</span>]) k--;</span><br><span class="line">				j++;k--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[j]+nums[k]&gt;target) k--;</span><br><span class="line">            <span class="keyword">else</span> j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过在这里要注意一个问题，就是题目中提到的“答案中不可以包含重复的三元组”，所以我们需要把相同的数字过滤掉。<br>其实很简单，只需要往下或者往前走一位，其他什么都不要做。</p>
<p>while j &lt; k &amp;&amp; MutNums[j] == MutNums[j+1] {<br>    j = j + 1<br>}</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()&lt;<span class="number">3</span>||nums.<span class="built_in">front</span>()&gt;<span class="number">0</span>||nums.<span class="built_in">back</span>()&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; vec;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>()<span class="number">-2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> target=<span class="number">0</span>-nums[i];</span><br><span class="line">            <span class="keyword">int</span> j=i+<span class="number">1</span>,k=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;k)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]+nums[k]==target)&#123;</span><br><span class="line">                    vec.<span class="built_in">push_back</span>(&#123;nums[i],nums[j],nums[k]&#125;);</span><br><span class="line">                    <span class="keyword">while</span>(j&lt;k&amp;&amp;nums[j]==nums[j+<span class="number">1</span>]) j++;</span><br><span class="line">                    <span class="keyword">while</span>(j&lt;k&amp;&amp;nums[k]==nums[k<span class="number">-1</span>]) k--;</span><br><span class="line">                    j++;k--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[j]+nums[k]&gt;target) k--;</span><br><span class="line">                <span class="keyword">else</span> j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="小提示："><a href="#小提示：" class="headerlink" title="小提示："></a>小提示：</h3><p>一维数组去重：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">vec = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">8</span> &#125;;</span><br><span class="line"><span class="function">set&lt;<span class="keyword">int</span>&gt; <span class="title">st</span><span class="params">(vec.begin(), vec.end())</span></span>;</span><br><span class="line">vec.<span class="built_in">assign</span>(st.<span class="built_in">begin</span>(), st.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<p>二维数组插入时去行重：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">set&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; vec = &#123;nums[a],nums[b],nums[c]&#125;;</span><br><span class="line"><span class="comment">//sort(vec.begin(),vec.end());</span></span><br><span class="line">ret.<span class="built_in">insert</span>(vec);         <span class="comment">//先插入集合set</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> x:ret)</span><br><span class="line">   result.<span class="built_in">push_back</span>(x);  <span class="comment">//set再插入容器vector</span></span><br></pre></td></tr></table></figure>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<p>一维数组迭代器输出：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"><span class="keyword">for</span> (it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); it++)</span><br><span class="line">cout &lt;&lt; *it &lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<p>二维数组迭代器输出：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;::iterator IE;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"><span class="keyword">for</span>(t=arr.<span class="built_in">begin</span>();t&lt;arr.<span class="built_in">end</span>();t++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (it=(*t).<span class="built_in">begin</span>();it&lt;(*t).<span class="built_in">end</span>();it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;*it&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>143. 重排链表</title>
    <url>/2021/06/27/LeetCode/LeetCode_20210627/</url>
    <content><![CDATA[<blockquote>
<p>参考链接： </p>
<ol>
<li><a href="https://leetcode-cn.com/problems/reorder-list/solution/zhong-pai-lian-biao-by-leetcode-solution/">https://leetcode-cn.com/problems/reorder-list/solution/zhong-pai-lian-biao-by-leetcode-solution/</a></li>
<li><a href="https://www.cnblogs.com/grandyang/p/4254860.html">https://www.cnblogs.com/grandyang/p/4254860.html</a></li>
</ol>
</blockquote>
<p>给定一个单链表 L：L0→L1→…→Ln-1→Ln ，<br>将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…</p>
<p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<p>示例1：</p>
<blockquote>
<p>给定链表 1-&gt;2-&gt;3-&gt;4, 重新排列为 1-&gt;4-&gt;2-&gt;3.</p>
</blockquote>
<p>示例2：</p>
<blockquote>
<p>给定链表 1-&gt;2-&gt;3-&gt;4-&gt;5, 重新排列为 1-&gt;5-&gt;2-&gt;4-&gt;3.</p>
</blockquote>
<span id="more"></span>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<h3 id="方法一-线性表"><a href="#方法一-线性表" class="headerlink" title="方法一:线性表"></a>方法一:线性表</h3><p>因为链表不支持下标访问，所以我们无法随机访问链表中任意位置的元素。</p>
<p>因此比较容易想到的一个方法是，我们利用线性表存储该链表，然后利用线性表可以下标访问的特点，直接按顺序访问指定元素，重建该链表即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;ListNode *&gt; vec;</span><br><span class="line">        ListNode *node = head;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            vec.<span class="built_in">emplace_back</span>(node);</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = vec.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            vec[i]-&gt;next = vec[j];</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            vec[j]-&gt;next = vec[i];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        vec[i]-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<h3 id="方法二：寻找链表中点-链表逆序-合并链表"><a href="#方法二：寻找链表中点-链表逆序-合并链表" class="headerlink" title="方法二：寻找链表中点 + 链表逆序 + 合并链表"></a>方法二：寻找链表中点 + 链表逆序 + 合并链表</h3><p>注意到目标链表即为将原链表的左半端和反转后的右半端合并后的结果。</p>
<p>这样我们的任务即可划分为三步：</p>
<ol>
<li>找到原链表的中点（参考「876. 链表的中间结点」）。<br> 我们可以使用快慢指针来 O(N) 地找到链表的中间节点。</li>
<li>将原链表的右半端反转（参考「206. 反转链表」）。<br> 我们可以使用迭代法实现链表的反转。</li>
<li>将原链表的两端合并。<br> 因为两链表长度相差不超过 1，因此直接合并即可。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//因为要将链表分成两个链表，所以应该找到中间节点mid的前一个节点，然后slow==nullptr断掉</span></span><br><span class="line">        <span class="comment">//所以使用的函数就应该是第二个版本的</span></span><br><span class="line">        ListNode *mid=<span class="built_in">midNode2</span>(head);        <span class="comment">//找到中间节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//下面这两个节点就是两端链表的头节点</span></span><br><span class="line">        ListNode* l1 = head;</span><br><span class="line">        ListNode* l2 = mid-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将链表断成两截</span></span><br><span class="line">        mid-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">        l2=<span class="built_in">reverseList</span>(l2);       <span class="comment">//将中间节点引导的链表进行反转</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//接下来就是将两个链表进行合并</span></span><br><span class="line">        <span class="built_in">mergeTwoList</span>(l1,l2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中间节点——版本1</span></span><br><span class="line">    <span class="function">ListNode *<span class="title">midNode</span><span class="params">(ListNode *head)</span></span>&#123;</span><br><span class="line">        ListNode *slow=head,*fast=head;</span><br><span class="line">        <span class="keyword">while</span>(fast&amp;&amp;fast-&gt;next)&#123;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">            fast=fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中间节点——版本2，找中间节点的前一个节点slow表示的</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">midNode2</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast-&gt;next != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反转链表</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *newHead = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            ListNode *t = head-&gt;next;</span><br><span class="line">            head-&gt;next = newHead;</span><br><span class="line">            newHead = head;</span><br><span class="line">            head = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并两个链表</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mergeTwoList</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//l1节点的数目与l2节点的数目不相差1，且l1 &gt;= l2</span></span><br><span class="line">        <span class="comment">//根据中间节点函数得出</span></span><br><span class="line">        <span class="comment">//原始链表节点数为偶，合并一定没问题</span></span><br><span class="line">        <span class="comment">//原始链表节点数为奇，l1比l2多一个节点</span></span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">nullptr</span> &amp;&amp; l2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ListNode* cur1 = l1-&gt;next;</span><br><span class="line">            ListNode* cur2 = l2-&gt;next;</span><br><span class="line"></span><br><span class="line">            l1-&gt;next = l2;</span><br><span class="line">            l1 = cur1;</span><br><span class="line"></span><br><span class="line">            l2-&gt;next = l1;</span><br><span class="line">            l2 = cur2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//将函数整合起来的写法</span></span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next || !head-&gt;next-&gt;next) <span class="keyword">return</span>;</span><br><span class="line">        ListNode *fast = head, *slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *mid = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *last = mid, *pre = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> (last) &#123;</span><br><span class="line">            ListNode *next = last-&gt;next;</span><br><span class="line">            last-&gt;next = pre;</span><br><span class="line">            pre = last;</span><br><span class="line">            last = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (head &amp;&amp; pre) &#123;</span><br><span class="line">            ListNode *next = head-&gt;next;</span><br><span class="line">            head-&gt;next = pre;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">            head-&gt;next-&gt;next = next;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>203. 移除链表元素</title>
    <url>/2021/06/19/LeetCode/Leetcode_20210619/</url>
    <content><![CDATA[<blockquote>
<p>参考链接：</p>
<ol>
<li><a href="https://leetcode-cn.com/problems/remove-linked-list-elements/">https://leetcode-cn.com/problems/remove-linked-list-elements/</a></li>
<li><a href="https://grandyang.com/leetcode/203/">https://grandyang.com/leetcode/203/</a></li>
</ol>
</blockquote>
<p>给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。</p>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<p>示例1：<br><img src="https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg" alt="在这里插入图片描述"></p>
<blockquote>
<p>输入：head = [1,2,6,3,4,5,6], val = 6<br>输出：[1,2,3,4,5]</p>
</blockquote>
<p>示例2：</p>
<blockquote>
<p>输入：head = [], val = 1<br>输出：[]</p>
</blockquote>
<p>示例3：</p>
<blockquote>
<p>输入：head = [7,7,7,7], val = 7<br>输出：[]</p>
</blockquote>
<span id="more"></span>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<h3 id="方法一：迭代"><a href="#方法一：迭代" class="headerlink" title="方法一：迭代"></a>方法一：迭代</h3><p>使用cursor-&gt;next=cursor-&gt;next-&gt;next的方式删除节点，注意while的判断条件为cursor-&gt;next</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode *dummy=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummy-&gt;next=head;</span><br><span class="line"></span><br><span class="line">        ListNode *cursor=dummy;</span><br><span class="line">        <span class="keyword">while</span>(cursor-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cursor-&gt;next-&gt;val==val)</span><br><span class="line">                cursor-&gt;next=cursor-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cursor=cursor-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//严格写法：要对删除的节点赋空</span></span><br><span class="line">		ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line"></span><br><span class="line">		LisNode *cursor=dummy;</span><br><span class="line">        <span class="keyword">while</span> (cursor-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cursor-&gt;next-&gt;val == val) &#123;</span><br><span class="line">                ListNode *t = cursor-&gt;next;</span><br><span class="line">                cursor-&gt;next = t-&gt;next;</span><br><span class="line">                t-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">delete</span> t;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cursor = cursor-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<h3 id="方法二：递归"><a href="#方法二：递归" class="headerlink" title="方法二：递归"></a>方法二：递归</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        head-&gt;next = <span class="built_in">removeElements</span>(head-&gt;next, val);</span><br><span class="line">        <span class="keyword">return</span> head-&gt;val == val ? head-&gt;next : head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>16. 最接近的三数之和</title>
    <url>/2021/07/08/LeetCode/LeetCode_20210708/</url>
    <content><![CDATA[<blockquote>
<p>参考链接： </p>
<ol>
<li><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/xiang-jiao-lian-biao-by-leetcode-solutio-a8jn/">https://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/xiang-jiao-lian-biao-by-leetcode-solutio-a8jn/</a></li>
<li><a href="https://www.cnblogs.com/grandyang/p/4510984.html">https://www.cnblogs.com/grandyang/p/4510984.html</a></li>
</ol>
</blockquote>
<p>给定一个包括 <code>n</code> 个整数的数组 <code>nums</code> 和 一个目标值 <code>target</code> 。找出 <code>nums</code> 中的三个整数，使得它们的和与 <code>target</code> 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<p>示例：</p>
<blockquote>
<p>输入：nums = [-1,2,1,-4], target = 1<br>输出：2<br>解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。</p>
</blockquote>
<span id="more"></span>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<h3 id="方法一：消除链表长度差-依次对比"><a href="#方法一：消除链表长度差-依次对比" class="headerlink" title="方法一：消除链表长度差 + 依次对比"></a>方法一：消除链表长度差 + 依次对比</h3><p>这道题让我们求最接近给定值的三数之和，是在之前那道 3Sum 的基础上又增加了些许难度，那么这道题让返回这个最接近于给定值的值，即要保证当前三数和跟给定值之间的差的绝对值最小，所以需要定义一个变量 absolute_val 用来记录差的绝对值，然后还是要先将数组排个序，然后开始遍历数组，思路跟那道三数之和很相似，都是先确定一个数，然后用两个指针 left 和 right 来滑动寻找另外两个数，每确定两个数，求出此三数之和，然后算和给定值的差的绝对值，然后和 absolute_val 比较并更新 absolute_val 和结果 closest 即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> closest=nums[<span class="number">0</span>]+nums[<span class="number">1</span>]+nums[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> absolute_val=<span class="built_in">abs</span>(closest-target);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>()<span class="number">-2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> j=i+<span class="number">1</span>,k=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(j&lt;k)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(nums[i]+nums[j]+nums[k]-target)&lt;absolute_val)&#123;</span><br><span class="line">                    closest=nums[i]+nums[j]+nums[k];</span><br><span class="line">                    absolute_val=<span class="built_in">abs</span>(closest-target);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>((nums[i]+nums[j]+nums[k]) &gt; target) k--;</span><br><span class="line">                <span class="keyword">else</span> j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> closest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<h3 id="方法二：对方法一进行优化"><a href="#方法二：对方法一进行优化" class="headerlink" title="方法二：对方法一进行优化"></a>方法二：对方法一进行优化</h3><p>我们还可以稍稍进行一下优化，每次判断一下，当 nums[i]*3 &gt; target 的时候，就可以直接比较 closest 和 nums[i] + nums[i+1] + nums[i+2] 的值，返回较小的那个，因为数组已经排过序了，后面的数字只会越来越大，就不必再往后比较了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> closest = nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> absolute_val = <span class="built_in">abs</span>(closest - target);</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() - <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] * <span class="number">3</span> &gt; target) </span><br><span class="line">				<span class="keyword">return</span> <span class="built_in">min</span>(closest, nums[i] + nums[i + <span class="number">1</span>] + nums[i + <span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> left = i + <span class="number">1</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">int</span> newDiff = <span class="built_in">abs</span>(sum - target);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (absolute_val &gt; newDiff) &#123;</span><br><span class="line">                    absolute_val = newDiff;</span><br><span class="line">                    closest = sum;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (sum &lt; target) </span><br><span class="line">					++left;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">					--right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> closest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><span><span style="font-family:Verdana, Arial, Helvetica, sans-serif;line-height:19px;text-indent:26px;"><span style="font-size:14px;"><span style="font-family:Arial;line-height:26px;"><br></span></span></span></span></p>

<h3 id="方法三：暴力"><a href="#方法三：暴力" class="headerlink" title="方法三：暴力"></a>方法三：暴力</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> closest=nums[<span class="number">0</span>]+nums[<span class="number">1</span>]+nums[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> absolute_val=<span class="built_in">abs</span>(closest-target);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>()<span class="number">-2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;nums.<span class="built_in">size</span>()<span class="number">-1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=j+<span class="number">1</span>;k&lt;nums.<span class="built_in">size</span>();k++)&#123;</span><br><span class="line">                    <span class="keyword">int</span> sum=nums[i]+nums[j]+nums[k];</span><br><span class="line">                    <span class="keyword">int</span> tmp=<span class="built_in">abs</span>(sum-target);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(tmp&lt;absolute_val)&#123;</span><br><span class="line">                        closest=sum;</span><br><span class="line">                        absolute_val=tmp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> closest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
</search>
